<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandbox - Infitwin</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/design-system.css">
    <link rel="stylesheet" href="../css/components/navigation.css">
    <link rel="stylesheet" href="../css/components/modal.css">
    <link rel="stylesheet" href="../css/components/button.css">
    <link rel="stylesheet" href="../css/pages/sandbox.css">
    <link rel="stylesheet" href="../css/pages/sandbox-extended.css">
    <!-- Nexus Graph Control v17.13.0 External CSS -->
    <link rel="stylesheet" href="../css/nexus-graph-v17.13.0.bundle.css">
    
    <!-- Firebase SDK v8 -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
    
    <!-- Neo4j Driver -->
    <script src="https://unpkg.com/neo4j-driver@5.15.0/lib/browser/neo4j-web.min.js"></script>
    
    <!-- Centralized Neo4j Connection -->
    <script src="../js/neo4j-connection.js"></script>
    
    <!-- Centralized UI Components -->
    <script type="module">
        import { Button } from '../js/components/ui/button.js';
        import { Modal } from '../js/components/ui/modal.js';
        import { getFileIcon, getNodeTypeIcon, getNodeColor, checkBundle, extractFaceFromImage } from '../js/utils/sandbox-utils.js';
        import { handleSandboxFileDrop, handleRealFile, handleArtifactFile, handleTestData, handleProductionFileDrop } from '../js/sandbox/file-handlers.js';
        import { initializeDragFunctionality, handleArtifactDragStart, handleArtifactDragEnd, handleFaceDragStart, handleFaceDragEnd } from '../js/sandbox/drag-handlers.js';
        import { Neo4jDataService } from '../js/services/neo4j-data-service.js';
        import { MetadataEditorIntegration } from '../js/sandbox/metadata-editor-integration.js';
        import { createArtifactThumbnail, createFaceThumbnail, createDraggableNodeElement, createFilterButton, createReviewFormContent, createNodeTypeFilters } from '../js/sandbox/ui-builders.js';
        import { sandboxState } from '../js/sandbox/sandbox-state.js';
        import { createSandboxEvents } from '../js/sandbox/sandbox-events.js';
        import { FirebaseIntegrationStub } from '../js/sandbox/firebase-integration-stub.js';
        import { createSandboxNeo4jIntegration } from '../js/sandbox/neo4j-integration.js';
        window.Button = Button;
        window.Modal = Modal;
        window.getFileIcon = getFileIcon;
        window.getNodeTypeIcon = getNodeTypeIcon;
        window.getNodeColor = getNodeColor;
        window.checkBundle = checkBundle;
        window.extractFaceFromImage = extractFaceFromImage;
        window.handleSandboxFileDrop = handleSandboxFileDrop;
        window.handleRealFile = handleRealFile;
        window.handleArtifactFile = handleArtifactFile;
        window.handleTestData = handleTestData;
        window.handleProductionFileDrop = handleProductionFileDrop;
        // Drag handlers will be initialized after modules are ready
        window.Neo4jDataService = Neo4jDataService;
        // UI Builder functions with backward compatibility
        window.createArtifactThumbnail = (fileId, fileData) => {
            return createArtifactThumbnail(fileId, fileData, {
                dragstart: window.handleArtifactDragStart,
                dragend: window.handleArtifactDragEnd
            });
        };
        window.createFaceThumbnail = (fileId, fileData, face, faceIndex) => {
            return createFaceThumbnail(fileId, fileData, face, faceIndex, {
                dragstart: window.handleFaceDragStart,
                dragend: window.handleFaceDragEnd
            });
        };
        window.createDraggableNodeElement = createDraggableNodeElement;
        window.createFilterButton = createFilterButton;
        window.createReviewFormContent = createReviewFormContent;
        window.createNodeTypeFilters = createNodeTypeFilters;
        // Initialize metadata editor
        window.metadataEditor = new MetadataEditorIntegration();
        
        // Make state management available globally
        window.sandboxState = sandboxState;
        
        // Initialize Firebase stub and event system
        const firebaseStub = new FirebaseIntegrationStub();
        window.sandboxEvents = createSandboxEvents(sandboxState, firebaseStub);
        
        // Initialize Neo4j integration and link to state
        window.sandboxNeo4j = createSandboxNeo4jIntegration(sandboxState);
        sandboxState.setNeo4jIntegration(window.sandboxNeo4j);
        
        // Initialize drag handlers now that modules are ready
        window.initializeDragFunctionality = (panelId) => initializeDragFunctionality(panelId, window.sandboxState.log, window.sandboxEvents.togglePanel);
        window.handleArtifactDragStart = (e) => handleArtifactDragStart(e, window.sandboxState.log);
        window.handleArtifactDragEnd = handleArtifactDragEnd;
        window.handleFaceDragStart = (e) => handleFaceDragStart(e, window.sandboxState.log);
        window.handleFaceDragEnd = handleFaceDragEnd;
    </script>
</head>
<body>
    <div class="symphony-dashboard">
        <!-- Shared Navigation Sidebar -->
        <div class="sidebar-nav-container"></div>
        
        <!-- Main Content Wrapper -->
        <div class="main-content-wrapper">
        <!-- App Header -->
        <div class="sandbox-header">
            <div class="header-left">
                <span class="header-icon">üß™</span>
                <h1>Sandbox - Graph Editor</h1>
            </div>
            <div class="header-right">
                <span>Session: active</span>
                <span>Status: ready</span>
                
                <!-- Post to Production Button -->
                <div id="postToProductionButton"></div>
            </div>
        </div>
        
        <!-- Smart Context Bar -->
        <div class="context-bar" id="contextBar">
            <div class="flex-center-gap-10">
                <span>‚ú®</span>
                <span id="changesText">0 changes pending in sandbox</span>
            </div>
            <span class="text-small-muted">
                Review changes before posting to production
            </span>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <div class="container">
                <!-- Toolbar -->
                <div class="toolbar">
                    <button class="toolbar-btn" title="Node List" onclick="window.sandboxEvents.togglePanel('node-list')">üë§</button>
                    <button class="toolbar-btn" title="Faces" onclick="window.sandboxEvents.togglePanel('faces')">üòä</button>
                    <button class="toolbar-btn" title="Artifacts" onclick="window.sandboxEvents.togglePanel('artifacts')">üìé</button>
                    <button class="toolbar-btn" title="Production Graph" onclick="window.sandboxEvents.togglePanel('production')">üîµ</button>
                    <button class="toolbar-btn" title="AI Assistant" onclick="window.sandboxEvents.togglePanel('ai-assistant')">ü§ñ</button>
                    <button class="toolbar-btn" title="Tools" onclick="window.sandboxEvents.togglePanel('tools')">üõ†Ô∏è</button>
                </div>
                
                <div class="content-area">
                    <div class="sandbox-panel">
                        <h3 class="section-title">üîß Sandbox Control</h3>
                        <div id="sandboxContainer" class="sandbox-container"></div>
                    </div>
                </div>
                
                <!-- Node List Panel -->
                <div id="node-listPanel" class="floating-panel node-list-panel">
                    <div class="panel-header" id="node-listHeader">
                        <div class="flex-center-gap">
                            <span>üë§</span>
                            <span class="text-bold-primary">Node List</span>
                        </div>
                        <button onclick="window.sandboxEvents.togglePanel('node-list')" class="panel-close">√ó</button>
                    </div>
                    <div class="panel-content">
                        <div class="text-muted" style="margin-bottom: 10px;">Drag actual nodes from your graph:</div>
                        
                        <!-- Node Type Filters -->
                        <div id="nodeTypeFilters" class="filter-section">
                            <div class="filter-label">FILTER BY TYPE:</div>
                            <div class="filter-buttons" id="nodeTypeFilterButtons">
                                <!-- Filter buttons will be dynamically added here -->
                            </div>
                        </div>
                        
                        <div id="nodeListContainer" class="content-list">
                            <div class="empty-state">
                                <div class="empty-state-icon">‚è≥</div>
                                <div>Loading nodes from Neo4j...</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Faces Panel -->
                <div id="facesPanel" class="floating-panel faces-panel">
                    <div class="panel-header" id="facesHeader">
                        <div class="flex-center-gap">
                            <span>üòä</span>
                            <span class="text-bold-purple">Faces</span>
                        </div>
                        <button onclick="window.sandboxEvents.togglePanel('faces')" class="panel-close">√ó</button>
                    </div>
                    <div class="panel-content-scroll">
                        <div class="text-muted" style="margin-bottom: 10px;">Drag faces to assign to people:</div>
                        <div id="facesLoading" class="loading-state">
                            <div>Loading faces...</div>
                        </div>
                        <div id="facesGrid" class="content-grid">
                            <!-- Face thumbnails will be loaded here -->
                        </div>
                    </div>
                </div>

                <!-- Artifacts Panel -->
                <div id="artifactsPanel" class="floating-panel artifacts-panel">
                    <div class="panel-header" id="artifactsHeader">
                        <div class="flex-center-gap">
                            <span>üìé</span>
                            <span class="text-bold-orange">Artifacts</span>
                        </div>
                        <button onclick="window.sandboxEvents.togglePanel('artifacts')" class="panel-close">√ó</button>
                    </div>
                    <div class="panel-content-scroll">
                        <div class="text-muted" style="margin-bottom: 10px;">Drag files to the graph:</div>
                        <div id="artifactsLoading" class="loading-state">
                            <div>Loading files...</div>
                        </div>
                        <div id="artifactsGrid" class="content-grid-files">
                            <!-- Thumbnails will be loaded here -->
                        </div>
                    </div>
                </div>

                <!-- Production Panel -->
                <div id="productionPanel" class="floating-panel production-panel">
                    <div class="panel-header" id="productionHeader" style="position: relative; z-index: 10;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span>üîµ</span>
                            <span style="font-weight: 600; color: #28a745;">Production Graph</span>
                        </div>
                        <button onclick="window.sandboxEvents.togglePanel('production')" class="panel-close">√ó</button>
                    </div>
                    <div id="productionContainer" style="flex: 1; overflow: hidden; background: #fafafa; border-radius: 6px; position: relative; min-height: 0; width: 100%; height: calc(100% - 60px); pointer-events: auto;"></div>
                </div>

                <!-- AI Assistant Panel -->
                <div id="ai-assistantPanel" class="floating-panel ai-assistant-panel">
                    <div class="panel-header" id="ai-assistantHeader">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span>ü§ñ</span>
                            <span style="font-weight: 600; color: #007bff;">AI Assistant</span>
                        </div>
                        <button onclick="window.sandboxEvents.togglePanel('ai-assistant')" class="panel-close">√ó</button>
                    </div>
                    <div style="flex: 1; display: flex; flex-direction: column; gap: 10px;">
                        <div style="background: #f8f9fa; border-radius: 6px; padding: 15px;">
                            <div style="font-weight: 600; margin-bottom: 8px;">Quick Actions:</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <button onclick="window.sandboxState.simulateChange()" style="padding: 8px; font-size: 12px; border: 1px solid #dee2e6; background: #f8f9fa; border-radius: 4px; cursor: pointer;">üîç Analyze</button>
                                <button onclick="window.sandboxState.simulateChange()" style="padding: 8px; font-size: 12px; border: 1px solid #dee2e6; background: #f8f9fa; border-radius: 4px; cursor: pointer;">‚úì Validate</button>
                                <button onclick="window.sandboxState.simulateChange()" style="padding: 8px; font-size: 12px; border: 1px solid #dee2e6; background: #f8f9fa; border-radius: 4px; cursor: pointer;">üîó Auto-Link</button>
                                <button onclick="window.sandboxState.simulateChange()" style="padding: 8px; font-size: 12px; border: 1px solid #dee2e6; background: #f8f9fa; border-radius: 4px; cursor: pointer;">üí° Suggest</button>
                            </div>
                        </div>
                        <div style="background: #f8f9fa; border-radius: 6px; padding: 15px; flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 8px;">AI Insights:</div>
                            <div style="font-size: 13px; color: #666; line-height: 1.4;">
                                Ready to assist with graph analysis and suggestions. Click any quick action to interact with the sandbox.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tools Panel -->
                <div id="toolsPanel" class="floating-panel tools-panel">
                    <div class="panel-header" id="toolsHeader">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span>üõ†Ô∏è</span>
                            <span style="font-weight: 600; color: #6c757d;">Tools</span>
                        </div>
                        <button onclick="window.sandboxEvents.togglePanel('tools')" class="panel-close">√ó</button>
                    </div>
                    <div style="flex: 1; background: #f8f9fa; border-radius: 6px; padding: 15px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <button style="padding: 15px; border: 1px solid #dee2e6; background: white; border-radius: 6px; cursor: pointer; text-align: center;">
                                <div style="font-size: 20px; margin-bottom: 5px;">üìä</div>
                                <small>Export</small>
                            </button>
                            <button style="padding: 15px; border: 1px solid #dee2e6; background: white; border-radius: 6px; cursor: pointer; text-align: center;">
                                <div style="font-size: 20px; margin-bottom: 5px;">üîÑ</div>
                                <small>Sync</small>
                            </button>
                            <button style="padding: 15px; border: 1px solid #dee2e6; background: white; border-radius: 6px; cursor: pointer; text-align: center;">
                                <div style="font-size: 20px; margin-bottom: 5px;">‚öôÔ∏è</div>
                                <small>Settings</small>
                            </button>
                            <button style="padding: 15px; border: 1px solid #dee2e6; background: white; border-radius: 6px; cursor: pointer; text-align: center;">
                                <div style="font-size: 20px; margin-bottom: 5px;">üîç</div>
                                <small>Search</small>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Nexus Graph Control v17.13.0 - Fixed React Component Export -->
    <script src="../bundles/nexus-graph-v17.13.0.bundle.js"></script>
    <!-- NexusMetadataEditor v5.2.0 bundle - Enhanced: Better edge form integration -->
    <script src="../bundles/nexus-metadata-editor-v5.2.0.bundle.js"></script>


    <script>
        // State management now handled by sandboxState module
        // Access state via: sandboxState.variableName
        
        // Direct access to modules - no backward compatibility wrappers
        
        // File drop handler for sandbox - creates attachment objects and updates graph
        // Called by Nexus onFileDrop callback with (targetId, fileData, isNode)
        async function handleSandboxFileDrop(targetId, fileData, isNode) {
            window.sandboxState.log(`üìé File drop on ${isNode ? 'node' : 'edge'} ${targetId}`);
            
            const target = {
                id: targetId,
                type: isNode ? 'node' : 'edge'
            };
            
            const attachment = await window.handleSandboxFileDrop(fileData, target, window.sandboxState.log);
            
            if (attachment && isNode) {
                const node = window.sandboxState.currentSandboxData.nodes.find(n => n.id === targetId);
                if (node) {
                    if (!node.attachments) node.attachments = [];
                    
                    node.attachments.push(attachment);
                    window.sandboxState.log(`‚úÖ Added attachment to node ${targetId}: ${attachment.name}`);
                    
                    // Trigger onDataChange to auto-save to Neo4j
                    if (window.sandboxState.sandboxGraphRef && window.sandboxState.sandboxGraphRef.current && window.sandboxState.sandboxGraphRef.current.updateData) {
                        window.sandboxState.sandboxGraphRef.current.updateData(window.sandboxState.currentSandboxData);
                    }
                }
            } else if (attachment && !isNode) {
                const edge = window.sandboxState.currentSandboxData.edges.find(e => e.id === targetId);
                if (edge) {
                    if (!edge.attachments) edge.attachments = [];
                    
                    edge.attachments.push(attachment);
                    window.sandboxState.log(`‚úÖ Added attachment to edge ${targetId}: ${attachment.name}`);
                    
                    // Trigger onDataChange to auto-save to Neo4j
                    if (window.sandboxState.sandboxGraphRef && window.sandboxState.sandboxGraphRef.current && window.sandboxState.sandboxGraphRef.current.updateData) {
                        window.sandboxState.sandboxGraphRef.current.updateData(window.sandboxState.currentSandboxData);
                    }
                }
            }
        }
        
        async function handleProductionFileDrop(targetId, fileData, isNode) {
            const target = {
                id: targetId,
                type: isNode ? 'node' : 'edge'
            };
            return window.handleProductionFileDrop(fileData, target, window.sandboxState.log);
        }
        
        // Handle face drops from the faces panel
        function handleFaceDropOnSandbox(targetId, faceNodeData, dropType, position) {
            window.sandboxState.log(`üòä Face drop: ${faceNodeData.name} on ${dropType}`);
            const faceData = faceNodeData.originalData;
            
            if (dropType === 'onto-canvas') {
                const newNode = {
                    id: faceNodeData.id,
                    name: faceNodeData.name,
                    label: faceNodeData.name,
                    type: 'person',
                    properties: {
                        ...faceData,
                        droppedAt: new Date().toISOString(),
                        source: 'faces-panel'
                    }
                };
                
                if (position) {
                    newNode.x = position.x;
                    newNode.y = position.y;
                }
                
                window.sandboxState.currentSandboxData = {
                    ...window.sandboxState.currentSandboxData,
                    nodes: [...window.sandboxState.currentSandboxData.nodes, newNode]
                };
                
                window.sandboxState.log(`‚úÖ Created person node from face: ${newNode.name}`);
                
            } else if (dropType === 'onto-node' && targetId) {
                const targetNode = window.sandboxState.currentSandboxData.nodes.find(n => n.id === targetId);
                if (targetNode) {
                    targetNode.properties = {
                        ...targetNode.properties,
                        faceData: faceData,
                        hasFace: true,
                        assignedAt: new Date().toISOString()
                    };
                    
                    window.sandboxState.log(`‚úÖ Assigned face to node ${targetNode.label || targetId}`);
                }
            }
            
            if (window.sandboxState.sandboxRoot) {
                
                // v17.12.0 uses destructuring pattern: const { NexusGraphControl } = window.NexusGraphControl;
                let NexusComponent;
                if (window.NexusGraphControl && window.NexusGraphControl.NexusGraphControl) {
                    // v17.12.0 and later pattern
                    const { NexusGraphControl } = window.NexusGraphControl;
                    NexusComponent = NexusGraphControl;
                } else if (window.NexusGraphControl && window.NexusGraphControl.default) {
                    NexusComponent = window.NexusGraphControl.default;
                } else if (typeof window.NexusGraphControl === 'function') {
                    NexusComponent = window.NexusGraphControl;
                } else {
                    console.error('Could not find NexusGraphControl component');
                    return;
                }
                
                const controlElement = React.createElement(NexusComponent, {
                    data: window.sandboxState.currentSandboxData,
                    title: "Sandbox",
                    hidePageHeader: true,
                    hideStatusBar: true,
                    useExternalMetadataEditor: true,
                    onDataChange: window.sandboxState.handleSandboxDataChange.bind(window.sandboxState),
                    onNodeDrop: handleSandboxNodeDrop,
                    onFileDrop: handleSandboxFileDrop,
                    onNodeClick: (node) => {
                        // Single click - just select/highlight
                    },
                    onNodeDoubleClick: (node) => {
                        // Double click - show metadata editor
                        window.metadataEditor.showEditorModal(node, (updatedNode) => {
                            window.sandboxState.log('üìù Node updated in sandbox:', updatedNode);
                            // The graph should auto-update when data changes
                        });
                    },
                    onEdgeClick: (edge) => {
                        // Single click - just select/highlight edge
                        console.log('üîó Edge selected:', edge.id);
                        window.sandboxState.log('üîó Edge selected:', edge.id);
                    },
                    onEdgeDoubleClick: (edge) => {
                        // Double click - show edge metadata editor
                        console.log('üîó Edge double-clicked:', edge.id);
                        window.sandboxState.log('üîó Edge double-clicked:', edge.id);
                        
                        // Find source and target nodes for context
                        const sourceNode = window.sandboxState.currentSandboxData.nodes.find(n => n.id === edge.source);
                        const targetNode = window.sandboxState.currentSandboxData.nodes.find(n => n.id === edge.target);
                        
                        if (sourceNode && targetNode) {
                            window.metadataEditor.showRelationshipEditorModal(edge, sourceNode, targetNode, 
                                (updatedEdge) => {
                                    window.sandboxState.log('üìù Edge updated in sandbox:', updatedEdge);
                                    // The graph should auto-update when data changes
                                },
                                window.sandboxState.sandboxGraphRef  // Pass graph ref for handleMetaSave
                            );
                        } else {
                            window.sandboxState.log('‚ùå Could not find source or target nodes for edge:', edge.id);
                        }
                    }
                });
                
                window.sandboxState.sandboxRoot.render(controlElement);
                
                window.sandboxState.changesCount++;
                window.sandboxState.updateChangesDisplay();
                
                window.sandboxState.log('üîÑ Sandbox re-rendered with face assignment');
            }
        }

        async function initializeSandbox() {
            if (!checkBundle()) {
                window.sandboxState.log('‚ùå Bundle not ready for sandbox');
                return;
            }
            
            window.sandboxState.log('üöÄ Initializing sandbox control...');
            const container = document.getElementById('sandboxContainer');
            
            try {
                if (window.sandboxState.sandboxRoot) {
                    window.sandboxState.sandboxRoot.unmount();
                    window.sandboxState.sandboxRoot = null;
                }
                
                if (!window.sandboxState.currentSandboxData) {
                    window.sandboxState.currentSandboxData = {
                        nodes: [],
                        edges: []
                    };
                }
                
                await window.sandboxNeo4j.loadExistingSandboxData();
                
                const NexusControl = window.NexusGraphControl.NexusGraphControl;
                
                const SandboxWrapper = React.forwardRef((props, ref) => {
                    return React.createElement(NexusControl, { ...props, ref });
                });
                
                window.sandboxState.sandboxGraphRef = React.createRef();
                
                const controlElement = React.createElement(SandboxWrapper, {
                    ref: window.sandboxState.sandboxGraphRef,
                    data: window.sandboxState.currentSandboxData,
                    title: "Sandbox",
                    hidePageHeader: true,
                    hideStatusBar: true,
                    useExternalMetadataEditor: true,
                    enableDelete: true,
                    onDataChange: window.sandboxState.handleSandboxDataChange.bind(window.sandboxState),
                    
                    onMetaSave: async (metaData) => {
                        window.sandboxState.log('üìù Meta save triggered:', metaData);
                        
                        try {
                            // Ensure connection
                            if (!window.Neo4jConnection.isConnected) {
                                await window.Neo4jConnection.connect();
                            }
                            
                            const userId = firebase.auth().currentUser?.uid;
                            const twinId = `${userId}-1`;
                            
                            if (metaData.entityType === 'node') {
                                if (metaData.action === 'create') {
                                    const newNode = await window.Neo4jConnection.createSandboxNode(
                                        metaData.updates,
                                        userId,
                                        twinId,
                                        window.sandboxState.currentInterviewId
                                    );
                                    window.sandboxState.log('‚úÖ Created sandbox node:', newNode);
                                } else {
                                    const updatedNode = await window.Neo4jConnection.updateSandboxNode(
                                        metaData.entityId,
                                        metaData.updates,
                                        metaData.deletedFields,
                                        userId,
                                        twinId,
                                        window.sandboxState.currentInterviewId
                                    );
                                    window.sandboxState.log('‚úÖ Updated/created sandbox node:', updatedNode);
                                }
                            } else if (metaData.entityType === 'edge' || metaData.entityType === 'relationship') {
                                
                                const { sourceId, targetId, type, category, stateMaps, ...otherProps } = metaData.updates;
                                
                                if (!sourceId || !targetId) {
                                    throw new Error('Relationship missing sourceId or targetId');
                                }
                                
                                const updatedRel = await window.Neo4jConnection.updateSandboxRelationship(
                                    metaData.entityId,
                                    metaData.updates,
                                    sourceId,
                                    targetId,
                                    type || 'RELATED_TO',
                                    window.sandboxState.currentInterviewId
                                );
                                window.sandboxState.log('‚úÖ Updated/created sandbox relationship as actual graph edge:', updatedRel);
                            }
                            
                            window.sandboxState.simulateChange();
                        } catch (error) {
                            window.sandboxState.log('‚ùå Meta save error:', error.message);
                            console.error('Full error details:', error);
                            if (window.Modal) {
                                new window.Modal({
                                    title: 'Save Error',
                                    content: `Failed to save changes: ${error.message}`,
                                    type: 'danger'
                                }).show();
                            }
                        }
                    },
                    
                    onNodeCreate: async (nodeData) => {
                        window.sandboxState.log('‚ûï Node create triggered:', nodeData);
                        
                        try {
                            const userId = firebase.auth().currentUser?.uid;
                            const twinId = `${userId}-1`;
                            
                            const sandboxNode = {
                                ...nodeData,
                                _isSandbox: true,
                                interviewId: window.sandboxState.currentInterviewId,
                                sessionId: window.sandboxState.currentInterviewId
                            };
                            
                            const createdNode = await window.Neo4jConnection.createSandboxNode(
                                sandboxNode,
                                userId,
                                twinId,
                                window.sandboxState.currentInterviewId
                            );
                            
                            window.sandboxState.currentSandboxData.nodes.push(createdNode);
                            window.sandboxState.simulateChange();
                            
                            return createdNode;
                        } catch (error) {
                            window.sandboxState.log('‚ùå Node create error:', error);
                            throw error;
                        }
                    },
                    
                    onNodeUpdate: async (nodeId, updates) => {
                        window.sandboxState.log('üìù Node update triggered:', nodeId, updates);
                        
                        try {
                            const updatedNode = await window.Neo4jConnection.updateSandboxNode(
                                nodeId,
                                updates,
                                []
                            );
                            
                            // Update local data
                            const nodeIndex = window.sandboxState.currentSandboxData.nodes.findIndex(n => n.id === nodeId);
                            if (nodeIndex >= 0) {
                                window.sandboxState.currentSandboxData.nodes[nodeIndex] = {
                                    ...window.sandboxState.currentSandboxData.nodes[nodeIndex],
                                    ...updates
                                };
                            }
                            
                            window.sandboxState.simulateChange();
                            return updatedNode;
                        } catch (error) {
                            window.sandboxState.log('‚ùå Node update error:', error);
                            throw error;
                        }
                    },
                    
                    onNodesDelete: async (nodeIds) => {
                        window.sandboxState.log('üóëÔ∏è Nodes delete triggered:', nodeIds);
                        
                        try {
                            if (!window.Neo4jConnection.isConnected) {
                                await window.Neo4jConnection.connect();
                            }
                            
                            for (const nodeId of nodeIds) {
                                try {
                                    const deleted = await window.Neo4jConnection.deleteSandboxNode(nodeId);
                                    
                                    if (deleted) {
                                        window.sandboxState.log('‚úÖ Node deleted from database: ' + nodeId);
                                    } else {
                                        window.sandboxState.log('‚ö†Ô∏è Node not found in database: ' + nodeId);
                                    }
                                } catch (error) {
                                    console.error(`Failed to delete node ${nodeId}:`, error);
                                    window.sandboxState.log('‚ùå Failed to delete node ' + nodeId + ': ' + error.message);
                                }
                            }
                            
                            window.sandboxState.currentSandboxData.nodes = window.sandboxState.currentSandboxData.nodes.filter(n => !nodeIds.includes(n.id));
                            window.sandboxState.currentSandboxData.edges = window.sandboxState.currentSandboxData.edges.filter(
                                e => !nodeIds.includes(e.source) && !nodeIds.includes(e.target)
                            );
                            window.sandboxState.simulateChange();
                            
                        } catch (error) {
                            window.sandboxState.log('‚ùå Nodes delete error:', error.message);
                            console.error('Full delete error:', error);
                            throw error;
                        }
                    },
                    
                    onEdgeCreate: async (edgeData) => {
                        window.sandboxState.log('üîó Edge create triggered:', edgeData);
                        
                        try {
                            const createdRel = await window.Neo4jConnection.createSandboxRelationship(
                                edgeData.source,
                                edgeData.target,
                                edgeData.label || edgeData.type || 'RELATED_TO',
                                edgeData.properties || {},
                                window.sandboxState.currentInterviewId
                            );
                            
                            window.sandboxState.currentSandboxData.edges.push({
                                ...edgeData,
                                id: createdRel.id
                            });
                            
                            window.sandboxState.simulateChange();
                            return createdRel;
                        } catch (error) {
                            window.sandboxState.log('‚ùå Edge create error:', error);
                            throw error;
                        }
                    },
                    
                    onEdgesDelete: async (edgeIds) => {
                        window.sandboxState.log('üóëÔ∏è Edges delete triggered:', edgeIds);
                        
                        try {
                            if (!window.Neo4jConnection.isConnected) {
                                await window.Neo4jConnection.connect();
                            }
                            
                            for (const edgeId of edgeIds) {
                                try {
                                    const deleted = await window.Neo4jConnection.deleteSandboxRelationship(edgeId);
                                    
                                    if (deleted) {
                                        window.sandboxState.log('‚úÖ Edge deleted from database: ' + edgeId);
                                    } else {
                                        window.sandboxState.log('‚ö†Ô∏è Edge not found in database: ' + edgeId);
                                    }
                                } catch (error) {
                                    console.error(`Failed to delete edge ${edgeId}:`, error);
                                    window.sandboxState.log('‚ùå Failed to delete edge ' + edgeId + ': ' + error.message);
                                }
                            }
                            
                            window.sandboxState.currentSandboxData.edges = window.sandboxState.currentSandboxData.edges.filter(e => !edgeIds.includes(e.id));
                            window.sandboxState.simulateChange();
                            
                        } catch (error) {
                            window.sandboxState.log('‚ùå Edges delete error:', error.message);
                            console.error('Full delete error:', error);
                            throw error;
                        }
                    },
                    
                    onNodeDrop: handleSandboxNodeDrop,
                    onFileDrop: handleSandboxFileDrop,
                    onFaceDrop: (nodeId, imageData, isNode) => {
                        
                        if (!isNode || !nodeId) {
                            console.log('‚ùå Face not dropped on a node');
                            return;
                        }
                        
                        const nodeIndex = window.sandboxState.currentSandboxData.nodes.findIndex(n => n.id === nodeId);
                        if (nodeIndex === -1) {
                            console.log('‚ùå Node not found:', nodeId);
                            return;
                        }
                        
                        let imageUrl = null;
                        if (typeof imageData === 'string') {
                            imageUrl = imageData;
                        } else if (imageData && typeof imageData === 'object') {
                            imageUrl = imageData.url || imageData.imageUrl || imageData.dataUrl || imageData.src;
                        }
                        
                        if (!imageUrl) {
                            console.log('‚ùå No image URL found in imageData:', imageData);
                            return;
                        }
                        
                        window.sandboxState.currentSandboxData.nodes[nodeIndex].imageUrl = imageUrl;
                        
                        if (window.sandboxState.sandboxGraphRef && window.sandboxState.sandboxGraphRef.current) {
                            if (window.sandboxState.sandboxGraphRef.current.updateData) {
                                window.sandboxState.sandboxGraphRef.current.updateData(window.sandboxState.currentSandboxData);
                            }
                        }
                        
                        window.sandboxState.simulateChange();
                    },
                    onNodeClick: (node) => {
                    },
                    onNodeDoubleClick: (node) => {
                        
                        window.metadataEditor.showEditorModal(node, null, window.sandboxState.sandboxGraphRef);
                    },
                    onEdgeClick: (edgeData) => {
                    },
                    onEdgeDoubleClick: (edgeData) => {
                        
                        const edge = edgeData;
                        
                        
                        let nodes = window.sandboxState.currentSandboxData.nodes;
                        if (window.sandboxState.sandboxGraphRef.current && window.sandboxState.sandboxGraphRef.current.getData) {
                            const graphData = window.sandboxState.sandboxGraphRef.current.getData();
                            if (graphData && graphData.nodes) {
                                nodes = graphData.nodes;
                            }
                        }
                        
                        const sourceNode = nodes.find(n => n.id === edge.source);
                        const targetNode = nodes.find(n => n.id === edge.target);
                        
                        
                        if (sourceNode && targetNode) {
                            try {
                                window.metadataEditor.showRelationshipEditorModal(
                                    edge,
                                    sourceNode,
                                    targetNode,
                                    null,
                                    window.sandboxState.sandboxGraphRef
                                );
                            } catch (error) {
                                console.error('‚ùå Error showing relationship editor:', error.message);
                                console.error('Full error:', error);
                            }
                        } else {
                            console.log('‚ùå Could not find source or target node for edge');
                            console.log('Looking for source:', edge.source);
                            console.log('Looking for target:', edge.target);
                            console.log('Available node IDs:', nodes.map(n => n.id));
                        }
                    }
                });
                
                window.sandboxState.sandboxRoot = ReactDOM.createRoot(container);
                window.sandboxState.sandboxRoot.render(controlElement);
                
                window.sandboxState.log('‚úÖ Sandbox control mounted with CRUD interface');
                
                window.sandboxState.initialDataLoaded = true;
                
                setTimeout(() => {
                    const hasContent = container.querySelector('svg') || 
                                     container.querySelector('canvas') ||
                                     container.innerHTML.includes('nexus');
                    window.sandboxState.log('üîç Sandbox content: ' + (hasContent ? 'Found ‚úÖ' : 'Missing ‚ùå'));
                    
                    if (window.sandboxState.sandboxGraphRef.current) {
                        window.sandboxState.log('‚úÖ Sandbox ref connected - handleMetaSave available:', 
                            typeof window.sandboxState.sandboxGraphRef.current.handleMetaSave === 'function');
                    }
                }, 1000);
                
            } catch (error) {
                window.sandboxState.log('‚ùå Sandbox error: ' + error.message);
            }
        }
        
        function observePanelResize(panelId) {
            const panel = document.getElementById(panelId + 'Panel');
            if (!panel || !window.ResizeObserver) return;
            
            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (panelId === 'production' && window.sandboxState.productionRoot) {
                        setTimeout(() => {
                            window.sandboxState.log('üìè Production panel resized, updating control');
                            initializeProduction();
                        }, 100);
                    }
                }
            });
            
            resizeObserver.observe(panel);
        }
        
        function handleProductionCopyToSandbox(selectedNodes) {
            window.sandboxState.log(`üìã Copying nodes from production to sandbox`);
            window.sandboxState.log('üîç Selected nodes:', selectedNodes);
            
            if (!selectedNodes || selectedNodes.length === 0) {
                window.sandboxState.log('‚ö†Ô∏è No nodes selected to copy');
                return;
            }
            
            const sandboxPanel = document.querySelector('.sandbox-panel');
            if (!sandboxPanel) {
                window.sandboxState.log('‚ùå Sandbox panel not found');
                return;
            }
            
            const nodesToCopy = Array.isArray(selectedNodes) ? selectedNodes : [selectedNodes];
            window.sandboxState.log(`üìä Copying ${nodesToCopy.length} nodes`);
            
            const copiedNodes = nodesToCopy.map((node, index) => {
                const newId = `${node.id}_copy_${Date.now()}_${index}`;
                
                const nodeData = node.data || node;
                const nodeName = nodeData.label || nodeData.name || node.label || node.name || 'Unnamed';
                const nodeType = nodeData.type || node.type || 'default';
                
                return {
                    id: newId,
                    name: `${nodeName} (Copy)`,
                    label: `${nodeName} (Copy)`,
                    type: nodeType,
                    originalData: {
                        ...(nodeData.originalData || {}),
                        copiedFrom: node.id,
                        copiedAt: new Date().toISOString()
                    }
                };
            });
            
            window.sandboxState.log('üìù Prepared nodes:', copiedNodes);
            
            if (!window.sandboxState.currentSandboxData) {
                window.sandboxState.currentSandboxData = { nodes: [], edges: [] };
            }
            
            window.sandboxState.currentSandboxData = {
                nodes: [...window.sandboxState.currentSandboxData.nodes, ...copiedNodes],
                edges: window.sandboxState.currentSandboxData.edges
            };
            
            if (window.sandboxState.sandboxRoot) {
                // Get the component using v17.12.0 pattern
                let NexusComponent;
                if (window.NexusGraphControl && window.NexusGraphControl.NexusGraphControl) {
                    const { NexusGraphControl } = window.NexusGraphControl;
                    NexusComponent = NexusGraphControl;
                } else {
                    NexusComponent = window.NexusGraphControl?.default || window.NexusGraphControl;
                }
                
                const controlElement = React.createElement(NexusComponent, {
                    data: window.sandboxState.currentSandboxData,
                    title: "Sandbox",
                    hidePageHeader: true,
                    hideStatusBar: true,
                    useExternalMetadataEditor: true,
                    onDataChange: window.sandboxState.handleSandboxDataChange.bind(window.sandboxState),
                    onNodeDrop: handleSandboxNodeDrop,
                    onFileDrop: handleSandboxFileDrop,
                    onNodeClick: (node) => {
                        // Single click - just select/highlight
                    },
                    onNodeDoubleClick: (node) => {
                        // Double click - show metadata editor
                        window.metadataEditor.showEditorModal(node, (updatedNode) => {
                            window.sandboxState.log('üìù Node updated in sandbox:', updatedNode);
                            // The graph should auto-update when data changes
                        });
                    },
                    onEdgeClick: (edge) => {
                        // Single click - just select/highlight edge
                        console.log('üîó Edge selected:', edge.id);
                        window.sandboxState.log('üîó Edge selected:', edge.id);
                    },
                    onEdgeDoubleClick: (edge) => {
                        // Double click - show edge metadata editor
                        console.log('üîó Edge double-clicked:', edge.id);
                        window.sandboxState.log('üîó Edge double-clicked:', edge.id);
                        
                        // Find source and target nodes for context
                        const sourceNode = window.sandboxState.currentSandboxData.nodes.find(n => n.id === edge.source);
                        const targetNode = window.sandboxState.currentSandboxData.nodes.find(n => n.id === edge.target);
                        
                        if (sourceNode && targetNode) {
                            window.metadataEditor.showRelationshipEditorModal(edge, sourceNode, targetNode, 
                                (updatedEdge) => {
                                    window.sandboxState.log('üìù Edge updated in sandbox:', updatedEdge);
                                    // The graph should auto-update when data changes
                                },
                                window.sandboxState.sandboxGraphRef  // Pass graph ref for handleMetaSave
                            );
                        } else {
                            window.sandboxState.log('‚ùå Could not find source or target nodes for edge:', edge.id);
                        }
                    }
                });
                
                window.sandboxState.sandboxRoot.render(controlElement);
                
                window.sandboxState.changesCount += copiedNodes.length;
                window.sandboxState.updateChangesDisplay();
                
                window.sandboxState.log(`‚úÖ Successfully copied ${copiedNodes.length} nodes to sandbox`);
                window.sandboxState.log(`üìä Sandbox now has ${window.sandboxState.currentSandboxData.nodes.length} nodes`);
            } else {
                window.sandboxState.log('‚ùå Sandbox not initialized');
            }
        }
        
        async function handleSandboxNodeDrop(targetId, nodeData, dropType, position) {
            try {
                // Check if this is a face drop (from the faces panel)
                if (nodeData.originalData && nodeData.originalData.type === 'face') {
                    handleFaceDropOnSandbox(targetId, nodeData, dropType, position);
                    return;
                }
                
                // Delegate to Neo4j integration module
                const result = await window.sandboxNeo4j.handleSandboxNodeDrop(nodeData, dropType, position, targetId);
                
                // Update local state and UI
                const state = window.sandboxState.getState();
                if (window.sandboxState.sandboxGraphRef.current && window.sandboxState.sandboxGraphRef.current.onNodeCreate) {
                    // Trigger through the Nexus control's callback
                    window.sandboxState.simulateChange();
                }
                
                await initializeSandbox();
                
                return result;
                
            } catch (error) {
                console.error('‚ùå Error handling node drop:', error);
                
                // Check for specific error types
                let errorMessage = 'Failed to add node: ';
                if (error.message && error.message.includes('Type mismatch')) {
                    errorMessage = 'Node data format error. The dropped node data is not in the expected format. Please check the console for details.';
                    console.error('üîç Type mismatch error - nodeData format issue. Expected format should match Nexus control requirements.');
                    console.error('Received nodeData:', nodeData);
                } else if (error.message && error.message.includes('expected MaP')) {
                    errorMessage = 'Internal Nexus control error. The control expects a different data structure. This is a known issue.';
                    console.error('üîç MaP error - This is an internal Nexus control issue that needs to be fixed in the control itself.');
                } else {
                    errorMessage += error.message;
                }
                
                // Try to show modal, but catch any errors
                try {
                    if (window.Modal) {
                        const modal = new window.Modal({
                            title: 'Drop Error',
                            content: errorMessage,
                            type: 'danger'
                        });
                        modal.show();
                    } else {
                        // Fallback alert if Modal not available
                        alert(errorMessage);
                    }
                } catch (modalError) {
                    console.error('Failed to show error modal:', modalError);
                    alert(errorMessage);
                }
            }
        }
        
        async function initializeProduction() {
            if (!checkBundle()) {
                window.sandboxState.log('‚ùå Bundle not ready for production');
                return;
            }
            
            window.sandboxState.log('üéØ Initializing production control...');
            const container = document.getElementById('productionContainer');
            
            try {
                if (window.sandboxState.productionRoot) {
                    window.sandboxState.productionRoot.unmount();
                    window.sandboxState.productionRoot = null;
                }
                
                // Get current user and twin ID
                let productionData = { nodes: [], edges: [] };
                
                if (firebase.auth().currentUser) {
                    const userId = firebase.auth().currentUser.uid;
                    const twinId = `${userId}-1`; // Using twin ID format from analysis
                    
                    window.sandboxState.log(`üîç Loading production data for user ${userId}, twin ${twinId}`);
                    productionData = await Neo4jDataService.loadProductionData(userId, twinId, window.sandboxState.log, getNodeColor);
                }
                
                // If no data found, suggest generating test data
                if (productionData.nodes.length === 0) {
                    window.sandboxState.log('üìä No production data found');
                    window.sandboxState.log('üí° Tip: Generate test data using the Admin page to see relationships');
                    productionData = {
                        nodes: [{
                            id: 'empty_message',
                            label: 'No Data Found',
                            type: 'message',
                            originalData: { message: 'Generate test data in Admin page' }
                        }],
                        edges: []
                    };
                } else {
                    window.sandboxState.log(`üéØ Production data structure:`, productionData);
                    window.sandboxState.log(`üìä Nodes: ${productionData.nodes.length}, Edges: ${productionData.edges.length}`);
                    
                    // If we have nodes but no edges, show a message
                    if (productionData.edges.length === 0 && productionData.nodes.length > 0) {
                        window.sandboxState.log('‚ö†Ô∏è Found nodes but no relationships - this may be expected for some graphs');
                    }
                }
                
                // Set container dimensions - don't override position to avoid covering header
                container.style.width = '100%';
                container.style.height = '100%';
                
                // Get the component using v17.12.0 pattern
                let NexusComponent;
                if (window.NexusGraphControl && window.NexusGraphControl.NexusGraphControl) {
                    const { NexusGraphControl } = window.NexusGraphControl;
                    NexusComponent = NexusGraphControl;
                } else {
                    NexusComponent = window.NexusGraphControl?.default || window.NexusGraphControl;
                }
                
                const controlElement = React.createElement(NexusComponent, {
                    data: productionData,
                    title: "Production",
                    hidePageHeader: true,
                    hideStatusBar: true,
                    useExternalMetadataEditor: true,  // Use our metadata editor
                    readOnly: false,  // Allow editing with the form
                    hideAddButton: true,
                    showCopyButton: true,
                    onCopyClick: handleProductionCopyToSandbox,
                    onFileDrop: handleProductionFileDrop,
                    onNodeClick: (node) => {
                        // Single click - just select/highlight
                        window.sandboxState.log('üñ±Ô∏è Production node selected:', node.id, node.name || node.label);
                    },
                    onNodeDoubleClick: (node) => {
                        // Double click - show metadata editor
                        window.sandboxState.log('üñ±Ô∏è Production node double-clicked:', node);
                        if (!window.metadataEditor) {
                            window.sandboxState.log('‚ùå Metadata editor not initialized!');
                            return;
                        }
                        window.metadataEditor.showEditorModal(node, (updatedNode) => {
                            window.sandboxState.log('üìù Node updated:', updatedNode);
                            // The graph should auto-update when data changes
                            // If not, we may need to trigger a refresh
                        });
                    },
                    width: '100%',
                    height: '100%',
                    style: { position: 'absolute', top: 0, left: 0, right: 0, bottom: 0 }
                });
                
                window.sandboxState.productionRoot = ReactDOM.createRoot(container);
                window.sandboxState.productionRoot.render(controlElement);
                
                window.sandboxState.log('‚úÖ Production control mounted');
                
                setTimeout(() => {
                    const hasContent = container.querySelector('svg') || 
                                     container.querySelector('canvas') ||
                                     container.innerHTML.includes('nexus');
                    window.sandboxState.log('üîç Production content: ' + (hasContent ? 'Found ‚úÖ' : 'Missing ‚ùå'));
                }, 1000);
                
            } catch (error) {
                window.sandboxState.log('‚ùå Production error: ' + error.message);
            }
        }
        
        // Remove backward compatibility wrappers - direct module access only
        
        // Firebase Integration Functions
        let firebaseInitialized = false;
        
        function initializeFirebase() {
            if (firebaseInitialized) return;
            
            try {
                // Initialize Firebase with configuration
                if (!firebase.apps.length) {
                    const firebaseConfig = {
                        apiKey: "AIzaSyB0SdtkO7ngsXP7B0geafpDv_xEBAujel8",
                        authDomain: "infitwin.firebaseapp.com",
                        projectId: "infitwin",
                        storageBucket: "infitwin.firebasestorage.app",
                        messagingSenderId: "833139648849",
                        appId: "1:833139648849:web:2768d8e37cf2a318018b70",
                        measurementId: "G-PEJN4ZMCZ6"
                    };
                    firebase.initializeApp(firebaseConfig);
                }
                firebaseInitialized = true;
                updateFirebaseStatus(true);
                window.sandboxState.log('üî• Firebase initialized');
                
                // Set up auth state listener
                firebase.auth().onAuthStateChanged(async (user) => {
                    if (user) {
                        window.sandboxState.log('üë§ User logged in:', user.email);
                        updateFirebaseStatus(true);
                    } else {
                        window.sandboxState.log('‚ùå No user logged in, attempting test login...');
                        // Try to login with test credentials
                        try {
                            await firebase.auth().signInWithEmailAndPassword('weezer@yev.com', '123456');
                            window.sandboxState.log('‚úÖ Test user logged in');
                        } catch (error) {
                            window.sandboxState.log('‚ùå Login failed:', error.message);
                            updateFirebaseStatus(false);
                        }
                    }
                });
            } catch (error) {
                window.sandboxState.log('‚ùå Firebase initialization error:', error);
                updateFirebaseStatus(false);
            }
        }
        
        function updateFirebaseStatus(connected) {
            const statusEl = document.getElementById('firebaseStatus');
            const statusText = document.getElementById('firebaseStatusText');
            if (statusEl && statusText) {
                if (connected) {
                    statusEl.classList.add('connected');
                    const user = firebase.auth().currentUser;
                    if (user) {
                        statusText.textContent = 'Connected: ' + user.email;
                    } else {
                        statusText.textContent = 'Connected';
                    }
                    statusEl.querySelector('span').style.background = '#28a745';
                } else {
                    statusEl.classList.remove('connected');
                    statusText.textContent = 'Disconnected';
                    statusEl.querySelector('span').style.background = '#dc3545';
                }
            }
        }
        
        function getCurrentSandboxData() {
            // Get current sandbox state
            const nodes = [];
            const edges = [];
            
            // In a real implementation, we'd get this from the Nexus control
            if (window.sandboxState.sandboxRoot) {
                // Simulate getting data
                nodes.push({
                    id: 'sandbox_node_1',
                    label: 'Sample Node',
                    type: 'person',
                    _isSandbox: true,
                    interviewId: 'interview_' + Date.now(),
                    sessionId: 'session_' + Date.now()
                });
            }
            
            return { nodes, edges, changesCount: window.sandboxState.changesCount };
        }
        
        
        // Load user artifacts from Firebase
        async function loadUserArtifacts() {
            if (!firebaseInitialized) {
                window.sandboxState.log('‚è≥ Firebase not initialized yet for artifacts');
                return;
            }
            
            const user = firebase.auth().currentUser;
            if (!user) {
                window.sandboxState.log('‚ùå No user logged in for artifacts');
                const loadingEl = document.getElementById('artifactsLoading');
                if (loadingEl) {
                    loadingEl.innerHTML = '<div style="color: #666;">Please log in to see files</div>';
                }
                return;
            }
            
            window.sandboxState.log('üìé Loading artifacts for user:', user.email, 'UID:', user.uid);
            
            const gridEl = document.getElementById('artifactsGrid');
            const loadingEl = document.getElementById('artifactsLoading');
            
            if (!gridEl || !loadingEl) {
                window.sandboxState.log('‚ùå Missing DOM elements for artifacts');
                return;
            }
            
            try {
                // Get user's files from Firestore
                const db = firebase.firestore();
                const filesRef = db.collection('users').doc(user.uid).collection('files');
                window.sandboxState.log('üîç Querying path: users/' + user.uid + '/files');
                
                // Try a simpler query first
                const snapshot = await filesRef.limit(50).get();
                
                window.sandboxState.log('üìä Query completed. Empty:', snapshot.empty, 'Size:', snapshot.size);
                
                if (snapshot.empty) {
                    loadingEl.innerHTML = '<div style="color: #666;">No files uploaded yet. <a href="../pages/my-files.html" style="color: #6B46C1;">Upload files</a></div>';
                    return;
                }
                
                loadingEl.style.display = 'none';
                gridEl.innerHTML = '';
                
                snapshot.forEach(doc => {
                    const file = doc.data();
                    window.sandboxState.log('üìÑ File:', doc.id, file.fileName || 'Unnamed');
                    const thumbnail = createArtifactThumbnail(doc.id, file);
                    gridEl.appendChild(thumbnail);
                });
                
                window.sandboxState.log('‚úÖ Loaded', snapshot.size, 'artifacts');
            } catch (error) {
                window.sandboxState.log('‚ùå Error loading artifacts:', error.message);
                console.error('Full error:', error);
                loadingEl.innerHTML = '<div style="color: #EF4444;">Error: ' + error.message + '</div>';
                
                // Check if it's a permission error
                if (error.code === 'permission-denied') {
                    loadingEl.innerHTML = '<div style="color: #EF4444;">Permission denied. Please check Firestore rules.</div>';
                } else if (error.message && error.message.includes('index')) {
                    // Try without orderBy if it's an index issue
                    try {
                        window.sandboxState.log('üîÑ Retrying without orderBy...');
                        const snapshot = await firebase.firestore()
                            .collection('users').doc(user.uid).collection('files')
                            .limit(50).get();
                        
                        if (!snapshot.empty) {
                            loadingEl.style.display = 'none';
                            gridEl.innerHTML = '';
                            
                            snapshot.forEach(doc => {
                                const file = doc.data();
                                const thumbnail = createArtifactThumbnail(doc.id, file);
                                gridEl.appendChild(thumbnail);
                            });
                            
                            window.sandboxState.log('‚úÖ Loaded', snapshot.size, 'artifacts (without orderBy)');
                        }
                    } catch (retryError) {
                        window.sandboxState.log('‚ùå Retry also failed:', retryError.message);
                    }
                }
            }
        }
        
        // Create draggable thumbnail for artifact
        // createArtifactThumbnail moved to ui-builders.js
        
        
        // Load user faces from Firebase
        async function loadUserFaces() {
            if (!firebaseInitialized) {
                window.sandboxState.log('‚è≥ Firebase not initialized yet for faces');
                return;
            }
            
            const user = firebase.auth().currentUser;
            if (!user) {
                window.sandboxState.log('‚ùå No user logged in for faces');
                const loadingEl = document.getElementById('facesLoading');
                if (loadingEl) {
                    loadingEl.innerHTML = '<div style="color: #666;">Please log in to see faces</div>';
                }
                return;
            }
            
            window.sandboxState.log('üë§ Loading faces for user:', user.email, 'UID:', user.uid);
            
            const gridEl = document.getElementById('facesGrid');
            const loadingEl = document.getElementById('facesLoading');
            
            if (!gridEl || !loadingEl) {
                window.sandboxState.log('‚ùå Missing DOM elements for faces');
                return;
            }
            
            try {
                // Get user's files from Firestore
                const db = firebase.firestore();
                const filesRef = db.collection('users').doc(user.uid).collection('files');
                window.sandboxState.log('üîç Querying for files with faces: users/' + user.uid + '/files');
                
                // Query for files that have extracted faces
                const snapshot = await filesRef.limit(100).get();
                
                window.sandboxState.log('üìä Files query completed. Size:', snapshot.size);
                
                loadingEl.style.display = 'none';
                gridEl.innerHTML = '';
                
                let totalFaces = 0;
                
                // Iterate through files and extract faces
                snapshot.forEach(doc => {
                    const fileData = doc.data();
                    
                    // Check if file has extracted faces
                    if (fileData.extractedFaces && Array.isArray(fileData.extractedFaces) && fileData.extractedFaces.length > 0) {
                        window.sandboxState.log('üì∑ Found file with faces:', fileData.fileName, 'Face count:', fileData.extractedFaces.length);
                        
                        // Log first face structure to understand the data
                        if (fileData.extractedFaces[0]) {
                            window.sandboxState.log('üîç First face structure:', JSON.stringify(fileData.extractedFaces[0]));
                        }
                        
                        // Create face thumbnails for each extracted face
                        fileData.extractedFaces.forEach((face, index) => {
                            const faceThumbnail = createFaceThumbnail(doc.id, fileData, face, index);
                            gridEl.appendChild(faceThumbnail);
                            totalFaces++;
                        });
                    }
                });
                
                window.sandboxState.log('‚úÖ Loaded', totalFaces, 'faces from', snapshot.size, 'files');
                
                if (totalFaces === 0) {
                    loadingEl.style.display = 'block';
                    loadingEl.innerHTML = '<div style="color: #666;">No faces found. <a href="../pages/my-files.html" style="color: #6B46C1;">Upload and vectorize photos</a></div>';
                }
                
            } catch (error) {
                window.sandboxState.log('‚ùå Error loading faces:', error.message);
                console.error('Full error:', error);
                loadingEl.innerHTML = '<div style="color: #EF4444;">Error: ' + error.message + '</div>';
            }
        }
        
        // createFaceThumbnail moved to ui-builders.js
        
        
        // Load node list using the service and handle UI
        async function loadNodeList() {
            try {
                const user = firebase.auth().currentUser;
                if (!user) {
                    showNodeListError('User not authenticated');
                    return;
                }
                
                const userId = user.uid;
                const twinId = `${userId}-1`;
                
                const nodesByType = await Neo4jDataService.loadNodeList(userId, twinId, window.sandboxState.log);
                
                const container = document.getElementById('nodeListContainer');
                container.innerHTML = '';
                
                if (Object.keys(nodesByType).length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <div class="empty-state-icon">üì≠</div>
                            <div>No nodes found in your graph</div>
                            <small style="color: #999;">Use the Admin page to generate test data</small>
                        </div>
                    `;
                    return;
                }
                
                // Create filter buttons
                createNodeTypeFilters(nodesByType);
                
                // Store nodes data globally for filtering
                window.nodeListData = nodesByType;
                
                // Render all nodes initially
                renderFilteredNodes(nodesByType);
                
            } catch (error) {
                window.sandboxState.log(`‚ùå Error loading node list: ${error.message}`);
                showNodeListError(`Error: ${error.message}`);
            }
        }
        
        function showNodeListError(message) {
            const container = document.getElementById('nodeListContainer');
            container.innerHTML = `
                <div style="background: white; padding: 15px; border-radius: 4px; text-align: center; color: #dc3545;">
                    <div style="font-size: 20px; margin-bottom: 5px;">‚ùå</div>
                    <div>${message}</div>
                </div>
            `;
        }
        
        
        function filterNodesByType(selectedType) {
            if (!window.nodeListData) return;
            
            if (selectedType === 'all') {
                renderFilteredNodes(window.nodeListData);
            } else {
                const filteredData = {};
                filteredData[selectedType] = window.nodeListData[selectedType] || [];
                renderFilteredNodes(filteredData);
            }
            
            window.sandboxState.log(`üîç Filtered node list to show: ${selectedType === 'all' ? 'all types' : selectedType}`);
        }
        
        function renderFilteredNodes(nodesByType) {
            const container = document.getElementById('nodeListContainer');
            container.innerHTML = '';
            
            // Create node elements for each type
            Object.keys(nodesByType).forEach(nodeType => {
                if (nodesByType[nodeType].length === 0) return;
                
                // Add type header
                const typeHeader = document.createElement('div');
                typeHeader.style.cssText = 'font-weight: 600; color: #333; margin: 15px 0 5px 0; font-size: 14px; text-transform: capitalize;';
                typeHeader.innerHTML = `${getNodeTypeIcon(nodeType)} ${nodeType}s (${nodesByType[nodeType].length})`;
                container.appendChild(typeHeader);
                
                // Sort nodes - alphabetically by last name for people, by name for others
                const sortedNodes = [...nodesByType[nodeType]].sort((a, b) => {
                    const aKey = a.sortKey || a.label || a.id;
                    const bKey = b.sortKey || b.label || b.id;
                    return aKey.localeCompare(bKey);
                });
                
                // Add sorted nodes of this type
                sortedNodes.forEach(node => {
                    const nodeElement = createDraggableNodeElement(node);
                    container.appendChild(nodeElement);
                });
            });
        }
        
        // Extract face from image using bounding box
        async function extractFaceFromImage(imageUrl, boundingBox) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous'; // Enable CORS for Firebase Storage URLs
                
                img.onload = function() {
                    // Create canvas for face extraction
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    

                    if (!boundingBox) {
                        reject(new Error('BoundingBox is undefined'));
                        return;
                    }
                    
                    // Convert percentage-based coordinates to pixels
                    // Firebase/AWS uses: Left, Top, Width, Height (all 0-1)
                    const x = (boundingBox.Left || boundingBox.left || boundingBox.x || 0) * img.width;
                    const y = (boundingBox.Top || boundingBox.top || boundingBox.y || 0) * img.height;
                    const width = (boundingBox.Width || boundingBox.width || boundingBox.w || 0) * img.width;
                    const height = (boundingBox.Height || boundingBox.height || boundingBox.h || 0) * img.height;
                    
                    window.sandboxState.log('üìè Face extraction coords - X:', x, 'Y:', y, 'W:', width, 'H:', height);
                    
                    // Set canvas size to extracted face dimensions (80x80 for thumbnails)
                    const thumbnailSize = 80;
                    canvas.width = thumbnailSize;
                    canvas.height = thumbnailSize;
                    
                    // Draw the face region from the source image, scaled to thumbnail size
                    ctx.drawImage(
                        img,
                        x,                  // Source X (pixels)
                        y,                  // Source Y (pixels)
                        width,              // Source Width (pixels)
                        height,             // Source Height (pixels)
                        0,                  // Destination X
                        0,                  // Destination Y
                        thumbnailSize,      // Destination Width
                        thumbnailSize       // Destination Height
                    );
                    
                    // Convert to data URL
                    const faceDataUrl = canvas.toDataURL('image/jpeg', 0.9);
                    resolve(faceDataUrl);
                };
                
                img.onerror = function() {
                    reject(new Error('Failed to load image for face extraction'));
                };
                
                img.src = imageUrl;
            });
        }
        
        
        // createReviewFormContent moved to ui-builders.js

        // Post to Production function
        async function postToProduction() {
            console.log('üìä Current sandbox data:', window.sandboxState.currentSandboxData);
            console.log('üî¢ Changes count:', window.sandboxState.changesCount);
            
            // Double-check we have changes to post
            if (window.sandboxState.changesCount === 0 || !window.sandboxState.currentSandboxData.nodes.length) {
                if (window.Modal) {
                    const modal = new window.Modal({
                        title: 'No Changes to Post',
                        content: 'There are no pending changes in the sandbox to post to production.',
                        type: 'info',
                        actions: [
                            {
                                text: 'OK',
                                type: 'primary',
                                action: () => {} // Modal will auto-hide
                            }
                        ]
                    });
                    modal.show();
                } else {
                    alert('No changes to post to production');
                }
                return;
            }
            

            if (activeReviewModal) {
                console.log('üîí Closing existing review modal');
                activeReviewModal.hide();
                activeReviewModal = null;
            }
            
            // Show review form modal
            if (window.Modal) {
                activeReviewModal = new window.Modal({
                    title: 'Review Changes Before Posting',
                    content: createReviewFormContent(),
                    size: 'medium',
                    type: 'default',
                    closable: true,
                    actions: [
                        {
                            text: 'Cancel',
                            type: 'secondary',
                            action: () => {} // Modal will auto-hide
                        },
                        {
                            text: 'Post to Production',
                            type: 'success',
                            icon: 'üì§',
                            action: () => {
                                console.log('üîò Modal Post to Production clicked!');
                                
                                // Get review notes
                                const reviewNotes = document.getElementById('reviewNotes')?.value || '';
                                console.log('üìù Review notes:', reviewNotes);
                                
                                // Hide the review modal immediately
                                console.log('üîí Hiding review modal...');
                                activeReviewModal.hide();
                                activeReviewModal = null;
                                
                                // Proceed with posting after modal is hidden
                                setTimeout(() => {
                                    console.log('üì§ Calling performPostToProduction...');
                                    performPostToProduction(reviewNotes);
                                }, 100);
                            }
                        }
                    ]
                });
                activeReviewModal.show();
            } else {
                // Fallback to simple confirm
                const confirmPost = confirm(`Are you sure you want to post ${window.sandboxState.changesCount} ${window.sandboxState.changesCount === 1 ? 'change' : 'changes'} to production?`);
                if (!confirmPost) return;
                await performPostToProduction('');
            }
        }
        
        // Perform the actual post to production
        async function performPostToProduction(reviewNotes) {
            console.log('üìù Review notes:', reviewNotes);
            
            try {
                // Disable button during processing
                const button = document.querySelector('#postToProductionButton button');
                if (button && window.Button) {
                    const buttonInstance = button._buttonInstance;
                    if (buttonInstance) {
                        buttonInstance.setLoading(true);
                    }
                }
                
                // Show loading modal
                let loadingModal;
                if (window.Modal) {
                    loadingModal = new window.Modal({
                        title: 'Posting to Production',
                        content: '<div style="text-align: center; padding: 20px;"><div style="font-size: 48px; margin-bottom: 10px;">‚è≥</div><div>Processing changes...</div></div>',
                        size: 'small',
                        closable: false,
                        closeOnBackdrop: false,
                        closeOnEscape: false
                    });
                    loadingModal.show();
                }
                
                // Post to production
                window.sandboxState.log('üì§ Posting changes to production...');
                window.sandboxState.log('üìù Review notes:', reviewNotes);
                window.sandboxState.log('üìä Nodes to save:', window.sandboxState.currentSandboxData.nodes.length);
                window.sandboxState.log('üîó Edges to save:', window.sandboxState.currentSandboxData.edges.length);
                
                // Save to Neo4j
                const success = await saveToNeo4j(window.sandboxState.currentSandboxData);
                
                if (!success) {
                    throw new Error('Failed to save to Neo4j');
                }
                
                // Reset changes count
                window.sandboxState.changesCount = 0;
                window.sandboxState.updateChangesDisplay();
                
                // Hide loading modal
                if (loadingModal) {
                    loadingModal.hide();
                }
                
                // Ensure review modal is closed
                if (activeReviewModal) {
                    console.log('üîí Ensuring review modal is closed after success');
                    activeReviewModal.hide();
                    activeReviewModal = null;
                }
                
                // Show success modal or alert
                if (window.Modal) {
                    const successModal = new window.Modal({
                        title: 'Success!',
                        content: '<div style="text-align: center; padding: 20px;"><div style="font-size: 48px; margin-bottom: 10px; color: #10B981;">‚úÖ</div><div>Changes successfully posted to production!</div></div>',
                        type: 'success',
                        size: 'small',
                        actions: [
                            {
                                text: 'OK',
                                type: 'primary',
                                action: () => {} // Modal will auto-hide
                            }
                        ]
                    });
                    successModal.show();
                } else {
                    alert('‚úÖ Changes successfully posted to production!');
                }
                
                window.sandboxState.log('‚úÖ Production update complete');
                
                // Re-enable button
                if (button && window.Button) {
                    const buttonInstance = button._buttonInstance;
                    if (buttonInstance) {
                        buttonInstance.setLoading(false);
                    }
                }
                
            } catch (error) {
                window.sandboxState.log('‚ùå Error posting to production:', error);
                
                // Show error modal or alert
                if (window.Modal) {
                    const errorModal = new window.Modal({
                        title: 'Error',
                        content: 'Failed to post changes to production. Please try again.',
                        type: 'danger',
                        actions: [
                            {
                                text: 'OK',
                                type: 'primary',
                                action: () => {} // Modal will auto-hide
                            }
                        ]
                    });
                    errorModal.show();
                } else {
                    alert('Error posting to production. Please try again.');
                }
                
                // Re-enable button on error
                const button = document.querySelector('#postToProductionButton button');
                if (button && window.Button) {
                    const buttonInstance = button._buttonInstance;
                    if (buttonInstance) {
                        buttonInstance.setLoading(false);
                    }
                }
            }
        }
        
        // Make it globally accessible
        window.postToProduction = postToProduction;

        // Save sandbox data to Neo4j using centralized connection
        async function saveToNeo4j(sandboxData) {
            try {
                // Get user ID and twin ID
                const userId = firebase.auth().currentUser?.uid;
                if (!userId) {
                    throw new Error('User not logged in');
                }
                const twinId = `${userId}-1`;
                
                // Connect to Neo4j if not already connected
                if (!window.Neo4jConnection.isConnected) {
                    const connected = await window.Neo4jConnection.connect();
                    if (!connected) {
                        throw new Error('Failed to connect to Neo4j');
                    }
                }
                
                // Use the new commit method that removes :Sandbox labels
                const result = await window.Neo4jConnection.commitSandboxToProduction(
                    window.sandboxState.currentInterviewId,
                    userId,
                    twinId
                );
                
                if (result.success) {
                    window.sandboxState.log(`‚úÖ Committed to production: ${result.newNodes} new nodes, ${result.updatedNodes} updated nodes, ${result.relationships} relationships`);
                    
                    // Clear sandbox data
                    window.sandboxState.currentSandboxData = { nodes: [], edges: [] };
                    
                    // Generate new interview ID for next session
                    window.sandboxState.currentInterviewId = `interview_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    
                    // Re-render empty sandbox
                    await initializeSandbox();
                    
                    // Refresh production panel if open
                    const productionPanel = document.getElementById('productionPanel');
                    if (productionPanel && productionPanel.classList.contains('open')) {
                        window.sandboxState.log('üîÑ Refreshing production panel...');
                        await initializeProduction();
                    }
                    
                    return true;
                } else {
                    throw new Error('Commit failed');
                }
                
            } catch (error) {
                window.sandboxState.log('‚ùå Error saving to Neo4j:', error);
                return false;
            }
        }
        // Function to add test data to sandbox (for testing only)
        window.addTestData = function() {
            window.sandboxState.currentSandboxData = {
                nodes: [
                    { id: 'test_person_1', label: 'Test Person 1', type: 'person', name: 'Test Person 1' },
                    { id: 'test_person_2', label: 'Test Person 2', type: 'person', name: 'Test Person 2' },
                    { id: 'test_event_1', label: 'Test Event', type: 'event', name: 'Test Event' }
                ],
                edges: [
                    { id: 'test_edge_1', source: 'test_person_1', target: 'test_event_1', label: 'ATTENDED' },
                    { id: 'test_edge_2', source: 'test_person_2', target: 'test_event_1', label: 'ORGANIZED' }
                ]
            };
            
            window.sandboxState.changesCount = 5;
            window.sandboxState.updateChangesDisplay();
            
            // Re-render sandbox with test data
            if (window.sandboxState.sandboxRoot) {
                // Get the component using v17.12.0 pattern
                let NexusComponent;
                if (window.NexusGraphControl && window.NexusGraphControl.NexusGraphControl) {
                    const { NexusGraphControl } = window.NexusGraphControl;
                    NexusComponent = NexusGraphControl;
                } else {
                    NexusComponent = window.NexusGraphControl?.default || window.NexusGraphControl;
                }
                
                const controlElement = React.createElement(NexusComponent, {
                    data: window.sandboxState.currentSandboxData,
                    title: "Sandbox",
                    hidePageHeader: true,
                    hideStatusBar: true,
                    useExternalMetadataEditor: true,
                    onDataChange: window.sandboxState.handleSandboxDataChange.bind(window.sandboxState),
                    onNodeDrop: handleSandboxNodeDrop,
                    onFileDrop: handleSandboxFileDrop,
                    onNodeClick: (node) => {
                        // Single click - just select/highlight
                    },
                    onNodeDoubleClick: (node) => {
                        // Double click - show metadata editor
                        window.metadataEditor.showEditorModal(node, (updatedNode) => {
                            window.sandboxState.log('üìù Node updated in sandbox:', updatedNode);
                            // The graph should auto-update when data changes
                        });
                    },
                    onEdgeClick: (edge) => {
                        // Single click - just select/highlight edge
                        console.log('üîó Edge selected:', edge.id);
                        window.sandboxState.log('üîó Edge selected:', edge.id);
                    },
                    onEdgeDoubleClick: (edge) => {
                        // Double click - show edge metadata editor
                        console.log('üîó Edge double-clicked:', edge.id);
                        window.sandboxState.log('üîó Edge double-clicked:', edge.id);
                        
                        // Find source and target nodes for context
                        const sourceNode = window.sandboxState.currentSandboxData.nodes.find(n => n.id === edge.source);
                        const targetNode = window.sandboxState.currentSandboxData.nodes.find(n => n.id === edge.target);
                        
                        if (sourceNode && targetNode) {
                            window.metadataEditor.showRelationshipEditorModal(edge, sourceNode, targetNode, 
                                (updatedEdge) => {
                                    window.sandboxState.log('üìù Edge updated in sandbox:', updatedEdge);
                                    // The graph should auto-update when data changes
                                },
                                window.sandboxState.sandboxGraphRef  // Pass graph ref for handleMetaSave
                            );
                        } else {
                            window.sandboxState.log('‚ùå Could not find source or target nodes for edge:', edge.id);
                        }
                    }
                });
                
                window.sandboxState.sandboxRoot.render(controlElement);
            }
            
            window.sandboxState.log('‚úÖ Test data added to sandbox');
        };

        window.addEventListener('load', () => {
            window.sandboxState.log('üì¶ Page loaded, checking scripts...');
            
            // Initialize Firebase first
            initializeFirebase();
            
            // Initialize Post to Production button
            setTimeout(() => {
                const buttonContainer = document.getElementById('postToProductionButton');
                if (buttonContainer) {
                    if (window.Button) {
                        // Use centralized Button component
                        const button = new window.Button({
                            text: 'Review & Post',
                            type: 'success',
                            icon: 'üìã',
                            disabled: true, // Start disabled since no changes initially
                            onClick: () => {
                                postToProduction();
                            }
                        });
                        buttonContainer.appendChild(button.element);
                        // Store reference for later use
                        button.element._buttonInstance = button;
                        
                        // Also add direct event listener as backup
                        button.element.addEventListener('click', () => {
                            postToProduction();
                        });
                        
                        window.sandboxState.log('‚úÖ Post to Production button initialized with centralized component');
                    } else {
                        // Fallback to simple button
                        const button = document.createElement('button');
                        button.textContent = 'üìã Review & Post';
                        button.onclick = postToProduction;
                        button.disabled = true; // Start disabled
                        button.style.cssText = `
                            background: #10B981;
                            color: white;
                            border: none;
                            padding: 8px 16px;
                            border-radius: 6px;
                            font-size: 14px;
                            font-weight: 500;
                            cursor: not-allowed;
                            opacity: 0.5;
                            display: flex;
                            align-items: center;
                            gap: 6px;
                        `;
                        buttonContainer.appendChild(button);
                        window.sandboxState.log('‚úÖ Post to Production button initialized with fallback');
                    }
                }
            }, 100);
            
            setTimeout(async () => {
                if (checkBundle()) {
                    window.sandboxState.log('‚úÖ Ready for testing');
                    await initializeSandbox();
                    
                    window.sandboxEvents.updateToolbarStates();
                } else {
                    window.sandboxState.log('‚ùå Scripts not loaded properly');
                }
            }, 500);
        });
    </script>
    
    <!-- Centralized Navigation -->
    <script src="../js/navigation.js"></script>
</body>
</html>