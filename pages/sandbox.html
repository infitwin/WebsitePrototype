<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sandbox - Infitwin</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../css/design-system.css">
    <link rel="stylesheet" href="../css/components/navigation.css">
    <link rel="stylesheet" href="../css/components/modal.css">
    <link rel="stylesheet" href="../css/components/button.css">
    <link rel="stylesheet" href="../css/pages/sandbox.css">
    
    <!-- Firebase SDK v8 -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-storage.js"></script>
    
    <!-- Neo4j Driver -->
    <script src="https://unpkg.com/neo4j-driver@5.15.0/lib/browser/neo4j-web.min.js"></script>
    
    <!-- Centralized Neo4j Connection -->
    <script src="../js/neo4j-connection.js"></script>
    
    <!-- Centralized UI Components -->
    <script type="module">
        import { Button } from '../js/components/ui/button.js';
        import { Modal } from '../js/components/ui/modal.js';
        import { getFileIcon, getNodeTypeIcon, getNodeColor, checkBundle, extractFaceFromImage } from '../js/utils/sandbox-utils.js';
        import { handleSandboxFileDrop, handleRealFile, handleArtifactFile, handleTestData, handleProductionFileDrop } from '../js/sandbox/file-handlers.js';
        window.Button = Button;
        window.Modal = Modal;
        window.getFileIcon = getFileIcon;
        window.getNodeTypeIcon = getNodeTypeIcon;
        window.getNodeColor = getNodeColor;
        window.checkBundle = checkBundle;
        window.extractFaceFromImage = extractFaceFromImage;
        window.handleSandboxFileDrop = handleSandboxFileDrop;
        window.handleRealFile = handleRealFile;
        window.handleArtifactFile = handleArtifactFile;
        window.handleTestData = handleTestData;
        window.handleProductionFileDrop = handleProductionFileDrop;
    </script>
    
    <style>

        body {
            font-family: var(--font-family-primary, 'Inter', sans-serif);
            background: var(--color-background);
            color: var(--color-text-primary);
            overflow: hidden;
            height: 100vh;
        }

        /* Main layout container */
        .symphony-dashboard {
            display: flex;
            height: 100vh;
        }

        /* Shared Navigation Sidebar - handled by navigation.css */
        .sidebar-nav-container {
            width: 80px;
            flex-shrink: 0;
            z-index: 200;
        }

        /* Main content wrapper */
        .main-content-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* App Header */
        .sandbox-header {
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-left h1 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 14px;
        }
        
        
        /* Main Content Area */
        .main-content {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .container {
            height: 100%;
            position: relative;
        }
        
        /* Smart Context Bar */
        .context-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 40px;
            background: linear-gradient(90deg, #28a745 0%, #20c997 100%);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            box-shadow: 0 -2px 4px rgba(0,0,0,0.1);
            z-index: 999;
            transform: translateY(40px);
            opacity: 0;
            transition: transform 200ms ease, opacity 200ms ease;
        }
        
        .context-bar.visible {
            transform: translateY(0);
            opacity: 1;
        }
        
        /* Toolbar */
        .toolbar {
            position: absolute;
            top: 20px;
            left: 20px;
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            display: flex;
            gap: 5px;
            padding: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1100;
        }
        
        .toolbar-btn {
            width: 45px;
            height: 45px;
            border: 2px solid var(--color-border);
            background: var(--color-background-hover);
            color: var(--color-text-primary);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }
        
        .toolbar-btn.active {
            background: var(--color-info);
            color: var(--color-text-inverse);
            border-color: var(--color-info);
        }
        
        /* Content Area */
        .content-area {
            padding: 20px;
            height: 100%;
        }
        
        .sandbox-panel {
            width: 100%;
            height: calc(100% - 40px);
            background: var(--color-background-card);
            border-radius: 8px;
            padding: var(--spacing-lg);
            box-shadow: 0 2px 4px var(--color-shadow-medium);
        }
        
        .sandbox-container {
            width: 100%;
            height: calc(100% - 50px);
            border: 2px solid var(--color-info);
            border-radius: 6px;
            background: var(--color-background-hover);
        }
    </style>
</head>
<body>
    <div class="symphony-dashboard">
        <!-- Shared Navigation Sidebar -->
        <div class="sidebar-nav-container"></div>
        
        <!-- Main Content Wrapper -->
        <div class="main-content-wrapper">
        <!-- App Header -->
        <div class="sandbox-header">
            <div class="header-left">
                <span style="font-size: 20px;">üß™</span>
                <h1>Sandbox - Graph Editor</h1>
            </div>
            <div class="header-right">
                <span>Session: active</span>
                <span>Status: ready</span>
                
                <!-- Post to Production Button -->
                <div id="postToProductionButton"></div>
            </div>
        </div>
        
        <!-- Smart Context Bar -->
        <div class="context-bar" id="contextBar">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span>‚ú®</span>
                <span id="changesText">0 changes pending in sandbox</span>
            </div>
            <span style="font-size: 12px; opacity: 0.9;">
                Review changes before posting to production
            </span>
        </div>
        
        <!-- Main Content -->
        <div class="main-content">
            <div class="container">
                <!-- Toolbar -->
                <div class="toolbar">
                    <button class="toolbar-btn" title="Node List" onclick="togglePanel('node-list')">üë§</button>
                    <button class="toolbar-btn" title="Faces" onclick="togglePanel('faces')">üòä</button>
                    <button class="toolbar-btn" title="Artifacts" onclick="togglePanel('artifacts')">üìé</button>
                    <button class="toolbar-btn" title="Production Graph" onclick="togglePanel('production')">üîµ</button>
                    <button class="toolbar-btn" title="AI Assistant" onclick="togglePanel('ai-assistant')">ü§ñ</button>
                    <button class="toolbar-btn" title="Tools" onclick="togglePanel('tools')">üõ†Ô∏è</button>
                </div>
                
                <div class="content-area">
                    <div class="sandbox-panel">
                        <h3 style="margin: 0 0 15px 0; color: #007bff;">üîß Sandbox Control</h3>
                        <div id="sandboxContainer" class="sandbox-container"></div>
                    </div>
                </div>
                
                <!-- Node List Panel -->
                <div id="node-listPanel" class="floating-panel node-list-panel">
                    <div class="panel-header" id="node-listHeader">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span>üë§</span>
                            <span style="font-weight: 600; color: #007bff;">Node List</span>
                        </div>
                        <button onclick="togglePanel('node-list')" class="panel-close">√ó</button>
                    </div>
                    <div style="flex: 1; display: flex; flex-direction: column; background: #f8f9fa; border-radius: 6px; padding: 15px;">
                        <div style="color: #666; font-size: 14px; margin-bottom: 10px;">Drag actual nodes from your graph:</div>
                        
                        <!-- Node Type Filters -->
                        <div id="nodeTypeFilters" style="display: none; margin-bottom: 15px; padding: 10px; background: white; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                            <div style="color: #333; font-size: 12px; font-weight: 600; margin-bottom: 8px;">FILTER BY TYPE:</div>
                            <div style="display: flex; flex-wrap: wrap; gap: 6px;" id="nodeTypeFilterButtons">
                                <!-- Filter buttons will be dynamically added here -->
                            </div>
                        </div>
                        
                        <div id="nodeListContainer" style="flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 8px;">
                            <div style="background: white; padding: 15px; border-radius: 4px; text-align: center; color: #666;">
                                <div style="font-size: 20px; margin-bottom: 5px;">‚è≥</div>
                                <div>Loading nodes from Neo4j...</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Faces Panel -->
                <div id="facesPanel" class="floating-panel faces-panel">
                    <div class="panel-header" id="facesHeader">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span>üòä</span>
                            <span style="font-weight: 600; color: #6f42c1;">Faces</span>
                        </div>
                        <button onclick="togglePanel('faces')" class="panel-close">√ó</button>
                    </div>
                    <div style="flex: 1; overflow-y: auto; background: #f8f9fa; border-radius: 6px; padding: 15px;">
                        <div style="color: #666; font-size: 14px; margin-bottom: 10px;">Drag faces to assign to people:</div>
                        <div id="facesLoading" style="text-align: center; padding: 20px;">
                            <div style="color: #666;">Loading faces...</div>
                        </div>
                        <div id="facesGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px;">
                            <!-- Face thumbnails will be loaded here -->
                        </div>
                    </div>
                </div>

                <!-- Artifacts Panel -->
                <div id="artifactsPanel" class="floating-panel artifacts-panel">
                    <div class="panel-header" id="artifactsHeader">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span>üìé</span>
                            <span style="font-weight: 600; color: #fd7e14;">Artifacts</span>
                        </div>
                        <button onclick="togglePanel('artifacts')" class="panel-close">√ó</button>
                    </div>
                    <div style="flex: 1; overflow-y: auto; background: #f8f9fa; border-radius: 6px; padding: 15px;">
                        <div style="color: #666; font-size: 14px; margin-bottom: 10px;">Drag files to the graph:</div>
                        <div id="artifactsLoading" style="text-align: center; padding: 20px;">
                            <div style="color: #666;">Loading files...</div>
                        </div>
                        <div id="artifactsGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px;">
                            <!-- Thumbnails will be loaded here -->
                        </div>
                    </div>
                </div>

                <!-- Production Panel -->
                <div id="productionPanel" class="floating-panel production-panel">
                    <div class="panel-header" id="productionHeader" style="position: relative; z-index: 10;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span>üîµ</span>
                            <span style="font-weight: 600; color: #28a745;">Production Graph</span>
                        </div>
                        <button onclick="togglePanel('production')" class="panel-close">√ó</button>
                    </div>
                    <div id="productionContainer" style="flex: 1; overflow: hidden; background: #fafafa; border-radius: 6px; position: relative; min-height: 0; width: 100%; height: calc(100% - 60px); pointer-events: auto;"></div>
                </div>

                <!-- AI Assistant Panel -->
                <div id="ai-assistantPanel" class="floating-panel ai-assistant-panel">
                    <div class="panel-header" id="ai-assistantHeader">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span>ü§ñ</span>
                            <span style="font-weight: 600; color: #007bff;">AI Assistant</span>
                        </div>
                        <button onclick="togglePanel('ai-assistant')" class="panel-close">√ó</button>
                    </div>
                    <div style="flex: 1; display: flex; flex-direction: column; gap: 10px;">
                        <div style="background: #f8f9fa; border-radius: 6px; padding: 15px;">
                            <div style="font-weight: 600; margin-bottom: 8px;">Quick Actions:</div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                <button onclick="simulateChange()" style="padding: 8px; font-size: 12px; border: 1px solid #dee2e6; background: #f8f9fa; border-radius: 4px; cursor: pointer;">üîç Analyze</button>
                                <button onclick="simulateChange()" style="padding: 8px; font-size: 12px; border: 1px solid #dee2e6; background: #f8f9fa; border-radius: 4px; cursor: pointer;">‚úì Validate</button>
                                <button onclick="simulateChange()" style="padding: 8px; font-size: 12px; border: 1px solid #dee2e6; background: #f8f9fa; border-radius: 4px; cursor: pointer;">üîó Auto-Link</button>
                                <button onclick="simulateChange()" style="padding: 8px; font-size: 12px; border: 1px solid #dee2e6; background: #f8f9fa; border-radius: 4px; cursor: pointer;">üí° Suggest</button>
                            </div>
                        </div>
                        <div style="background: #f8f9fa; border-radius: 6px; padding: 15px; flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 8px;">AI Insights:</div>
                            <div style="font-size: 13px; color: #666; line-height: 1.4;">
                                Ready to assist with graph analysis and suggestions. Click any quick action to interact with the sandbox.
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tools Panel -->
                <div id="toolsPanel" class="floating-panel tools-panel">
                    <div class="panel-header" id="toolsHeader">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <span>üõ†Ô∏è</span>
                            <span style="font-weight: 600; color: #6c757d;">Tools</span>
                        </div>
                        <button onclick="togglePanel('tools')" class="panel-close">√ó</button>
                    </div>
                    <div style="flex: 1; background: #f8f9fa; border-radius: 6px; padding: 15px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <button style="padding: 15px; border: 1px solid #dee2e6; background: white; border-radius: 6px; cursor: pointer; text-align: center;">
                                <div style="font-size: 20px; margin-bottom: 5px;">üìä</div>
                                <small>Export</small>
                            </button>
                            <button style="padding: 15px; border: 1px solid #dee2e6; background: white; border-radius: 6px; cursor: pointer; text-align: center;">
                                <div style="font-size: 20px; margin-bottom: 5px;">üîÑ</div>
                                <small>Sync</small>
                            </button>
                            <button style="padding: 15px; border: 1px solid #dee2e6; background: white; border-radius: 6px; cursor: pointer; text-align: center;">
                                <div style="font-size: 20px; margin-bottom: 5px;">‚öôÔ∏è</div>
                                <small>Settings</small>
                            </button>
                            <button style="padding: 15px; border: 1px solid #dee2e6; background: white; border-radius: 6px; cursor: pointer; text-align: center;">
                                <div style="font-size: 20px; margin-bottom: 5px;">üîç</div>
                                <small>Search</small>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="../js/nexus-graph-control-v16.3.0.bundle.min.js"></script>

    <script>
        let sandboxRoot = null;
        let productionRoot = null;
        let debugMessages = [];
        let openPanels = [];
        let changesCount = 0;
        let initialDataLoaded = false;
        let currentSandboxData = { nodes: [], edges: [] };
        let activeReviewModal = null; // Track active review modal
        
        // Drag functionality for panels - each panel gets its own drag state
        function initializeDragFunctionality(panelId) {
            const panel = document.getElementById(panelId + 'Panel');
            const header = document.getElementById(panelId + 'Header');
            
            log(`üîß Initializing drag for ${panelId} panel`);
            log(`   Panel found: ${!!panel}, Header found: ${!!header}`);
            
            if (!panel || !header) {
                log(`‚ùå Missing elements for ${panelId} drag`);
                return;
            }
            
            // Local drag state for this panel
            let isDragging = false;
            let currentPanel = null;
            let dragOffset = { x: 0, y: 0 };
            
            // Remove any existing listeners first
            const newHeader = header.cloneNode(true);
            header.parentNode.replaceChild(newHeader, header);
            
            // Re-attach close button functionality
            const closeBtn = newHeader.querySelector('button');
            if (closeBtn) {
                closeBtn.onclick = () => window.togglePanel(panelId);
            }
            
            const startDrag = (e) => {
                log(`üñ±Ô∏è ${panelId} header clicked, target: ${e.target.tagName}`);
                
                // Don't start drag if clicking on close button
                if (e.target.tagName === 'BUTTON') {
                    log(`üö´ Clicked close button, not dragging`);
                    return;
                }
                
                isDragging = true;
                currentPanel = panel;
                panel.classList.add('dragging');
                
                const rect = panel.getBoundingClientRect();
                dragOffset.x = e.clientX - rect.left;
                dragOffset.y = e.clientY - rect.top;
                
                log('üîµ ' + panelId + ' panel drag started');
                e.preventDefault();
            };
            
            const drag = (e) => {
                if (!isDragging || !currentPanel) return;
                
                const x = e.clientX - dragOffset.x;
                const y = e.clientY - dragOffset.y;
                
                // Keep panel within viewport bounds
                const maxX = window.innerWidth - currentPanel.offsetWidth;
                const maxY = window.innerHeight - currentPanel.offsetHeight;
                
                const constrainedX = Math.max(80, Math.min(x, maxX)); // 80px for sidebar
                const constrainedY = Math.max(0, Math.min(y, maxY));
                
                currentPanel.style.left = constrainedX + 'px';
                currentPanel.style.top = constrainedY + 'px';
                currentPanel.style.right = 'auto';
                currentPanel.style.bottom = 'auto';
                
                e.preventDefault();
            };
            
            const stopDrag = () => {
                if (isDragging && currentPanel) {
                    isDragging = false;
                    currentPanel.classList.remove('dragging');
                    log('üîµ ' + panelId + ' panel drag ended');
                    currentPanel = null;
                }
            };
            
            newHeader.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
        }
        
        function log(message) {
            // Logging disabled for production
            console.log(message);
        }
        
        function updateChangesDisplay() {
            const shouldShow = initialDataLoaded && changesCount > 0;
            const contextBar = document.getElementById('contextBar');
            const changesText = document.getElementById('changesText');
            
            if (contextBar) {
                if (shouldShow) {
                    contextBar.classList.add('visible');
                } else {
                    contextBar.classList.remove('visible');
                }
            }
            
            if (changesText) {
                changesText.textContent = changesCount + ' ' + (changesCount === 1 ? 'change' : 'changes') + ' pending in sandbox';
            }
            
            // Update Review & Post button state
            const button = document.querySelector('#postToProductionButton button');
            if (button && button._buttonInstance) {
                button._buttonInstance.setDisabled(changesCount === 0);
            } else if (button) {
                // Fallback for simple button
                button.disabled = changesCount === 0;
                button.style.opacity = changesCount === 0 ? '0.5' : '1';
                button.style.cursor = changesCount === 0 ? 'not-allowed' : 'pointer';
            }
        }
        
        function simulateChange() {
            if (initialDataLoaded) {
                changesCount++;
                updateChangesDisplay();
                log('Change recorded: ' + changesCount + ' total');
            }
        }
        
        // Create wrapper functions that provide the log function to imported handlers
        function handleSandboxFileDropWrapper(file, target) {
            return window.handleSandboxFileDrop(file, target, log);
        }
        
        function handleProductionFileDropWrapper(file, target) {
            return window.handleProductionFileDrop(file, target, log);
        }
        
        // Use the wrapper functions for Nexus callbacks
        const handleSandboxFileDrop = handleSandboxFileDropWrapper;
        const handleProductionFileDrop = handleProductionFileDropWrapper;
        
        
        // Handle face drops from the faces panel
        function handleFaceDropOnSandbox(targetId, faceNodeData, dropType, position) {
            log(`üòä Face drop: ${faceNodeData.name} on ${dropType}`);
            const faceData = faceNodeData.originalData;
            
            if (dropType === 'onto-canvas') {
                // Create a new person node with the face
                const newNode = {
                    id: faceNodeData.id,
                    name: faceNodeData.name,
                    label: faceNodeData.name,
                    type: 'person',
                    properties: {
                        ...faceData,
                        droppedAt: new Date().toISOString(),
                        source: 'faces-panel'
                    }
                };
                
                // Add position if provided
                if (position) {
                    newNode.x = position.x;
                    newNode.y = position.y;
                }
                
                currentSandboxData = {
                    ...currentSandboxData,
                    nodes: [...currentSandboxData.nodes, newNode]
                };
                
                log(`‚úÖ Created person node from face: ${newNode.name}`);
                
            } else if (dropType === 'onto-node' && targetId) {
                // Attach face to existing node (e.g., assign face to person)
                const targetNode = currentSandboxData.nodes.find(n => n.id === targetId);
                if (targetNode) {
                    targetNode.properties = {
                        ...targetNode.properties,
                        faceData: faceData,
                        hasFace: true,
                        assignedAt: new Date().toISOString()
                    };
                    
                    log(`‚úÖ Assigned face to node ${targetNode.label || targetId}`);
                }
            }
            
            // Re-render the sandbox
            if (sandboxRoot) {
                const controlElement = React.createElement(window.NexusGraphControl.NexusGraphControl, {
                    data: currentSandboxData,
                    title: "Sandbox",
                    hidePageHeader: true,
                    hideStatusBar: true,
                    useExternalMetadataEditor: false,
                    onDataChange: (newData) => {
                        currentSandboxData = newData;
                        simulateChange();
                    },
                    onNodeDrop: handleSandboxNodeDrop,
                    onFileDrop: handleSandboxFileDrop
                });
                
                sandboxRoot.render(controlElement);
                
                // Track the change
                changesCount++;
                updateChangesDisplay();
                
                log('üîÑ Sandbox re-rendered with face assignment');
            }
        }

        function initializeSandbox() {
            if (!checkBundle()) {
                log('‚ùå Bundle not ready for sandbox');
                return;
            }
            
            log('üöÄ Initializing sandbox control...');
            const container = document.getElementById('sandboxContainer');
            
            try {
                if (sandboxRoot) {
                    sandboxRoot.unmount();
                    sandboxRoot = null;
                }
                
                // Initialize with empty sandbox data
                if (!currentSandboxData) {
                    currentSandboxData = {
                        nodes: [],
                        edges: []
                    };
                }
                
                const controlElement = React.createElement(window.NexusGraphControl.NexusGraphControl, {
                    data: currentSandboxData,
                    title: "Sandbox",
                    hidePageHeader: true,
                    hideStatusBar: true,
                    useExternalMetadataEditor: false,
                    onDataChange: (newData) => {
                        currentSandboxData = newData;
                        simulateChange();
                    },
                    onNodeDrop: handleSandboxNodeDrop,
                    onFileDrop: handleSandboxFileDrop
                });
                
                sandboxRoot = ReactDOM.createRoot(container);
                sandboxRoot.render(controlElement);
                
                log('‚úÖ Sandbox control mounted');
                
                // Mark initial data as loaded - don't count as change
                initialDataLoaded = true;
                
                setTimeout(() => {
                    const hasContent = container.querySelector('svg') || 
                                     container.querySelector('canvas') ||
                                     container.innerHTML.includes('nexus');
                    log('üîç Sandbox content: ' + (hasContent ? 'Found ‚úÖ' : 'Missing ‚ùå'));
                }, 1000);
                
            } catch (error) {
                log('‚ùå Sandbox error: ' + error.message);
            }
        }
        
        // Observe panel resize and update Nexus control
        function observePanelResize(panelId) {
            const panel = document.getElementById(panelId + 'Panel');
            if (!panel || !window.ResizeObserver) return;
            
            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (panelId === 'production' && productionRoot) {
                        // Re-initialize production control on resize
                        setTimeout(() => {
                            log('üìè Production panel resized, updating control');
                            initializeProduction();
                        }, 100);
                    }
                }
            });
            
            resizeObserver.observe(panel);
        }
        
        // Handle copying nodes from production to sandbox
        function handleProductionCopyToSandbox(selectedNodes) {
            log(`üìã Copying nodes from production to sandbox`);
            log('üîç Selected nodes:', selectedNodes);
            
            if (!selectedNodes || selectedNodes.length === 0) {
                log('‚ö†Ô∏è No nodes selected to copy');
                return;
            }
            
            // Make sure sandbox is open
            const sandboxPanel = document.querySelector('.sandbox-panel');
            if (!sandboxPanel) {
                log('‚ùå Sandbox panel not found');
                return;
            }
            
            // Handle both single node and array of nodes
            const nodesToCopy = Array.isArray(selectedNodes) ? selectedNodes : [selectedNodes];
            log(`üìä Copying ${nodesToCopy.length} nodes`);
            
            // Prepare the copied nodes with new IDs
            const copiedNodes = nodesToCopy.map((node, index) => {
                const newId = `${node.id}_copy_${Date.now()}_${index}`;
                
                // Extract the actual node data - handle different possible structures
                const nodeData = node.data || node;
                const nodeName = nodeData.label || nodeData.name || node.label || node.name || 'Unnamed';
                const nodeType = nodeData.type || node.type || 'default';
                
                return {
                    id: newId,
                    name: `${nodeName} (Copy)`,
                    label: `${nodeName} (Copy)`,
                    type: nodeType,
                    originalData: {
                        ...(nodeData.originalData || {}),
                        copiedFrom: node.id,
                        copiedAt: new Date().toISOString()
                    }
                };
            });
            
            log('üìù Prepared nodes:', copiedNodes);
            
            // Update sandbox data
            if (!currentSandboxData) {
                currentSandboxData = { nodes: [], edges: [] };
            }
            
            currentSandboxData = {
                nodes: [...currentSandboxData.nodes, ...copiedNodes],
                edges: currentSandboxData.edges
            };
            
            // Re-render the sandbox with new data
            if (sandboxRoot) {
                const controlElement = React.createElement(window.NexusGraphControl.NexusGraphControl, {
                    data: currentSandboxData,
                    title: "Sandbox",
                    hidePageHeader: true,
                    hideStatusBar: true,
                    useExternalMetadataEditor: false,
                    onDataChange: (newData) => {
                        currentSandboxData = newData;
                        simulateChange();
                    },
                    onNodeDrop: handleSandboxNodeDrop,
                    onFileDrop: handleSandboxFileDrop
                });
                
                sandboxRoot.render(controlElement);
                
                // Track the change
                changesCount += copiedNodes.length;
                updateChangesDisplay();
                
                log(`‚úÖ Successfully copied ${copiedNodes.length} nodes to sandbox`);
                log(`üìä Sandbox now has ${currentSandboxData.nodes.length} nodes`);
            } else {
                log('‚ùå Sandbox not initialized');
            }
        }
        
        // Handle node drops on sandbox
        function handleSandboxNodeDrop(targetId, nodeData, dropType, position) {
            log(`üéØ Node drop on sandbox: targetId=${targetId}, dropType=${dropType}`);
            log('üì¶ Node data:', nodeData);
            log('üìç Position:', position);
            
            if (!currentSandboxData) {
                currentSandboxData = { nodes: [], edges: [] };
            }
            
            // Check if this is a face drop (from the faces panel)
            if (nodeData.originalData && nodeData.originalData.type === 'face') {
                handleFaceDropOnSandbox(targetId, nodeData, dropType, position);
                return;
            }
            
            if (dropType === 'onto-canvas') {
                // Drop on empty canvas - create new node
                const newNode = {
                    id: `${nodeData.id}_drop_${Date.now()}`,
                    name: nodeData.name || nodeData.label || 'Unnamed',
                    label: nodeData.label || nodeData.name || 'Unnamed',
                    type: nodeData.type || 'default',
                    originalData: {
                        ...nodeData.properties,
                        sourceId: nodeData.id,
                        droppedAt: new Date().toISOString(),
                        dropType: 'canvas'
                    }
                };
                
                // Add position if provided
                if (position) {
                    newNode.x = position.x;
                    newNode.y = position.y;
                }
                
                currentSandboxData = {
                    ...currentSandboxData,
                    nodes: [...currentSandboxData.nodes, newNode]
                };
                
                log(`‚úÖ Created new node: ${newNode.id}`);
                
            } else if (dropType === 'onto-node' && targetId) {
                // Drop on existing node - create relationship
                const newNodeId = `${nodeData.id}_drop_${Date.now()}`;
                const newNode = {
                    id: newNodeId,
                    name: nodeData.name || nodeData.label || 'Unnamed',
                    label: nodeData.label || nodeData.name || 'Unnamed',
                    type: nodeData.type || 'default',
                    originalData: {
                        ...nodeData.properties,
                        sourceId: nodeData.id,
                        droppedAt: new Date().toISOString(),
                        dropType: 'node',
                        linkedTo: targetId
                    }
                };
                
                // Position near the target node
                const targetNode = currentSandboxData.nodes.find(n => n.id === targetId);
                if (targetNode && position) {
                    newNode.x = position.x;
                    newNode.y = position.y;
                }
                
                // Create edge between new node and target
                const newEdge = {
                    id: `edge_${Date.now()}`,
                    source: newNodeId,
                    target: targetId,
                    label: 'RELATED_TO'
                };
                
                currentSandboxData = {
                    nodes: [...currentSandboxData.nodes, newNode],
                    edges: [...currentSandboxData.edges, newEdge]
                };
                
                log(`‚úÖ Created node ${newNodeId} with edge to ${targetId}`);
                
            } else if (dropType === 'onto-edge' && targetId) {
                // Drop on edge - associate with relationship
                log(`üìé Associating node with edge ${targetId}`);
                // For now, just log this scenario
                // Could implement edge metadata updates here
            }
            
            // Re-render the sandbox with updated data
            if (sandboxRoot) {
                const controlElement = React.createElement(window.NexusGraphControl.NexusGraphControl, {
                    data: currentSandboxData,
                    title: "Sandbox",
                    hidePageHeader: true,
                    hideStatusBar: true,
                    useExternalMetadataEditor: false,
                    onDataChange: (newData) => {
                        currentSandboxData = newData;
                        simulateChange();
                    },
                    onNodeDrop: handleSandboxNodeDrop,
                    onFileDrop: handleSandboxFileDrop
                });
                
                sandboxRoot.render(controlElement);
                
                // Track the change
                changesCount++;
                updateChangesDisplay();
                
                log('üîÑ Sandbox re-rendered with dropped node');
            }
        }
        
        async function initializeProduction() {
            if (!checkBundle()) {
                log('‚ùå Bundle not ready for production');
                return;
            }
            
            log('üéØ Initializing production control...');
            const container = document.getElementById('productionContainer');
            
            try {
                if (productionRoot) {
                    productionRoot.unmount();
                    productionRoot = null;
                }
                
                // Get current user and twin ID
                let productionData = { nodes: [], edges: [] };
                
                if (firebase.auth().currentUser) {
                    const userId = firebase.auth().currentUser.uid;
                    const twinId = `${userId}-1`; // Using twin ID format from analysis
                    
                    log(`üîç Loading production data for user ${userId}, twin ${twinId}`);
                    productionData = await loadProductionDataFromNeo4j(userId, twinId);
                }
                
                // If no data found, suggest generating test data
                if (productionData.nodes.length === 0) {
                    log('üìä No production data found');
                    log('üí° Tip: Generate test data using the Admin page to see relationships');
                    productionData = {
                        nodes: [{
                            id: 'empty_message',
                            label: 'No Data Found',
                            type: 'message',
                            originalData: { message: 'Generate test data in Admin page' }
                        }],
                        edges: []
                    };
                } else {
                    log(`üéØ Production data structure:`, productionData);
                    log(`üìä Nodes: ${productionData.nodes.length}, Edges: ${productionData.edges.length}`);
                    
                    // If we have nodes but no edges, show a message
                    if (productionData.edges.length === 0 && productionData.nodes.length > 0) {
                        log('‚ö†Ô∏è Found nodes but no relationships - this may be expected for some graphs');
                    }
                }
                
                // Set container dimensions - don't override position to avoid covering header
                container.style.width = '100%';
                container.style.height = '100%';
                
                const controlElement = React.createElement(window.NexusGraphControl.NexusGraphControl, {
                    data: productionData,
                    title: "Production",
                    hidePageHeader: true,
                    hideStatusBar: true,
                    useExternalMetadataEditor: false,
                    readOnly: true,
                    hideAddButton: true,
                    showCopyButton: true,
                    onCopyClick: handleProductionCopyToSandbox,
                    onFileDrop: handleProductionFileDrop,
                    width: '100%',
                    height: '100%',
                    style: { position: 'absolute', top: 0, left: 0, right: 0, bottom: 0 }
                });
                
                productionRoot = ReactDOM.createRoot(container);
                productionRoot.render(controlElement);
                
                log('‚úÖ Production control mounted');
                
                setTimeout(() => {
                    const hasContent = container.querySelector('svg') || 
                                     container.querySelector('canvas') ||
                                     container.innerHTML.includes('nexus');
                    log('üîç Production content: ' + (hasContent ? 'Found ‚úÖ' : 'Missing ‚ùå'));
                }, 1000);
                
            } catch (error) {
                log('‚ùå Production error: ' + error.message);
            }
        }
        
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId + 'Panel');
            if (!panel) {
                log('‚ùå Panel not found: ' + panelId);
                return;
            }
            
            const isOpen = panel.classList.contains('open');
            
            if (isOpen) {
                panel.classList.remove('open');
                log('üìã ' + panelId + ' panel closed');
                
                // Clean up production panel when closing
                if (panelId === 'production' && productionRoot) {
                    productionRoot.unmount();
                    productionRoot = null;
                    log('üßπ Production panel unmounted');
                }
            } else {
                panel.classList.add('open');
                log('üìã ' + panelId + ' panel opened');
                
                // Initialize drag functionality for any panel
                initializeDragFunctionality(panelId);
                
                // Initialize resize observer for all panels
                observePanelResize(panelId);
                
                // Special handling for production panel
                if (panelId === 'production') {
                    setTimeout(async () => {
                        await initializeProduction();
                    }, 200);
                }
                
                // Load node list when panel is opened
                if (panelId === 'node-list') {
                    // Initialize Firebase first if needed for authentication
                    if (!firebaseInitialized) {
                        initializeFirebase();
                        // Wait for auth state to be established
                        setTimeout(() => {
                            if (firebase.auth().currentUser) {
                                loadNodeList();
                            }
                        }, 2000);
                    } else if (firebase.auth().currentUser) {
                        loadNodeList();
                    } else {
                        // Try to wait for auth
                        log('‚è≥ Waiting for authentication...');
                        const unsubscribe = firebase.auth().onAuthStateChanged((user) => {
                            if (user) {
                                loadNodeList();
                                unsubscribe(); // Stop listening after first auth
                            }
                        });
                    }
                }
                
                // Load artifacts when panel is opened
                if (panelId === 'artifacts') {
                    // Initialize Firebase first if needed
                    if (!firebaseInitialized) {
                        initializeFirebase();
                        // Wait for auth state to be established
                        setTimeout(() => {
                            if (firebase.auth().currentUser) {
                                loadUserArtifacts();
                            }
                        }, 2000);
                    } else if (firebase.auth().currentUser) {
                        loadUserArtifacts();
                    } else {
                        // Try to wait for auth
                        log('‚è≥ Waiting for authentication...');
                        const unsubscribe = firebase.auth().onAuthStateChanged((user) => {
                            if (user) {
                                loadUserArtifacts();
                                unsubscribe(); // Stop listening after first auth
                            }
                        });
                    }
                }
                
                // Load faces when panel is opened
                if (panelId === 'faces') {
                    // Initialize Firebase first if needed
                    if (!firebaseInitialized) {
                        initializeFirebase();
                        // Wait for auth state to be established
                        setTimeout(() => {
                            if (firebase.auth().currentUser) {
                                loadUserFaces();
                            }
                        }, 2000);
                    } else if (firebase.auth().currentUser) {
                        loadUserFaces();
                    } else {
                        // Try to wait for auth
                        log('‚è≥ Waiting for authentication...');
                        const unsubscribe = firebase.auth().onAuthStateChanged((user) => {
                            if (user) {
                                loadUserFaces();
                                unsubscribe(); // Stop listening after first auth
                            }
                        });
                    }
                }
            }
            
            // Update toolbar button states
            updateToolbarStates();
        }
        
        function updateToolbarStates() {
            document.querySelectorAll('.toolbar-btn').forEach(btn => {
                const title = btn.getAttribute('title');
                let panelId = '';
                
                // Map button titles to panel IDs
                switch(title) {
                    case 'Node List': panelId = 'node-list'; break;
                    case 'Faces': panelId = 'faces'; break;
                    case 'Artifacts': panelId = 'artifacts'; break;
                    case 'Production Graph': panelId = 'production'; break;
                    case 'AI Assistant': panelId = 'ai-assistant'; break;
                    case 'Tools': panelId = 'tools'; break;
                }
                
                const panel = document.getElementById(panelId + 'Panel');
                
                if (panel && panel.classList.contains('open')) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }
        
        // Make togglePanel globally accessible
        window.togglePanel = togglePanel;
        
        // Firebase Integration Functions
        let firebaseInitialized = false;
        
        // Neo4j Configuration for Production Data
        const neo4jConfig = {
            uri: 'neo4j+s://80dc1193.databases.neo4j.io',
            username: 'neo4j',
            password: 'lCHngJO-NHNGSF5fcj7ApgdImgBA6qGUGWaKWxAY2eA'
        };
        let neo4jDriver = null;
        let firebaseConfig = {
            apiKey: "AIzaSyB0SdtkO7ngsXP7B0geafpDv_xEBAujel8",
            authDomain: "infitwin.firebaseapp.com",
            projectId: "infitwin",
            storageBucket: "infitwin.firebasestorage.app",
            messagingSenderId: "833139648849",
            appId: "1:833139648849:web:2768d8e37cf2a318018b70",
            measurementId: "G-PEJN4ZMCZ6"
        };
        
        function initializeFirebase() {
            if (firebaseInitialized) return;
            
            try {
                // Initialize Firebase
                firebase.initializeApp(firebaseConfig);
                firebaseInitialized = true;
                updateFirebaseStatus(true);
                log('üî• Firebase initialized');
                
                // Set up auth state listener
                firebase.auth().onAuthStateChanged(async (user) => {
                    if (user) {
                        log('üë§ User logged in:', user.email);
                        // Update Firebase status
                        updateFirebaseStatus(true);
                    } else {
                        log('‚ùå No user logged in, attempting test login...');
                        // Try to login with test credentials
                        try {
                            await firebase.auth().signInWithEmailAndPassword('weezer@yev.com', '123456');
                            log('‚úÖ Test user logged in');
                        } catch (error) {
                            log('‚ùå Login failed:', error.message);
                            updateFirebaseStatus(false);
                        }
                    }
                });
            } catch (error) {
                log('‚ùå Firebase initialization error:', error);
                updateFirebaseStatus(false);
            }
        }
        
        function updateFirebaseStatus(connected) {
            const statusEl = document.getElementById('firebaseStatus');
            const statusText = document.getElementById('firebaseStatusText');
            if (statusEl && statusText) {
                if (connected) {
                    statusEl.classList.add('connected');
                    const user = firebase.auth().currentUser;
                    if (user) {
                        statusText.textContent = 'Connected: ' + user.email;
                    } else {
                        statusText.textContent = 'Connected';
                    }
                    statusEl.querySelector('span').style.background = '#28a745';
                } else {
                    statusEl.classList.remove('connected');
                    statusText.textContent = 'Disconnected';
                    statusEl.querySelector('span').style.background = '#dc3545';
                }
            }
        }
        
        function getCurrentSandboxData() {
            // Get current sandbox state
            const nodes = [];
            const edges = [];
            
            // In a real implementation, we'd get this from the Nexus control
            if (sandboxRoot) {
                // Simulate getting data
                nodes.push({
                    id: 'sandbox_node_1',
                    label: 'Sample Node',
                    type: 'person',
                    _isSandbox: true,
                    interviewId: 'interview_' + Date.now(),
                    sessionId: 'session_' + Date.now()
                });
            }
            
            return { nodes, edges, changesCount };
        }
        
        
        // Load user artifacts from Firebase
        async function loadUserArtifacts() {
            if (!firebaseInitialized) {
                log('‚è≥ Firebase not initialized yet for artifacts');
                return;
            }
            
            const user = firebase.auth().currentUser;
            if (!user) {
                log('‚ùå No user logged in for artifacts');
                const loadingEl = document.getElementById('artifactsLoading');
                if (loadingEl) {
                    loadingEl.innerHTML = '<div style="color: #666;">Please log in to see files</div>';
                }
                return;
            }
            
            log('üìé Loading artifacts for user:', user.email, 'UID:', user.uid);
            
            const gridEl = document.getElementById('artifactsGrid');
            const loadingEl = document.getElementById('artifactsLoading');
            
            if (!gridEl || !loadingEl) {
                log('‚ùå Missing DOM elements for artifacts');
                return;
            }
            
            try {
                // Get user's files from Firestore
                const db = firebase.firestore();
                const filesRef = db.collection('users').doc(user.uid).collection('files');
                log('üîç Querying path: users/' + user.uid + '/files');
                
                // Try a simpler query first
                const snapshot = await filesRef.limit(50).get();
                
                log('üìä Query completed. Empty:', snapshot.empty, 'Size:', snapshot.size);
                
                if (snapshot.empty) {
                    loadingEl.innerHTML = '<div style="color: #666;">No files uploaded yet. <a href="../pages/my-files.html" style="color: #6B46C1;">Upload files</a></div>';
                    return;
                }
                
                loadingEl.style.display = 'none';
                gridEl.innerHTML = '';
                
                snapshot.forEach(doc => {
                    const file = doc.data();
                    log('üìÑ File:', doc.id, file.fileName || 'Unnamed');
                    const thumbnail = createArtifactThumbnail(doc.id, file);
                    gridEl.appendChild(thumbnail);
                });
                
                log('‚úÖ Loaded', snapshot.size, 'artifacts');
            } catch (error) {
                log('‚ùå Error loading artifacts:', error.message);
                console.error('Full error:', error);
                loadingEl.innerHTML = '<div style="color: #EF4444;">Error: ' + error.message + '</div>';
                
                // Check if it's a permission error
                if (error.code === 'permission-denied') {
                    loadingEl.innerHTML = '<div style="color: #EF4444;">Permission denied. Please check Firestore rules.</div>';
                } else if (error.message && error.message.includes('index')) {
                    // Try without orderBy if it's an index issue
                    try {
                        log('üîÑ Retrying without orderBy...');
                        const snapshot = await firebase.firestore()
                            .collection('users').doc(user.uid).collection('files')
                            .limit(50).get();
                        
                        if (!snapshot.empty) {
                            loadingEl.style.display = 'none';
                            gridEl.innerHTML = '';
                            
                            snapshot.forEach(doc => {
                                const file = doc.data();
                                const thumbnail = createArtifactThumbnail(doc.id, file);
                                gridEl.appendChild(thumbnail);
                            });
                            
                            log('‚úÖ Loaded', snapshot.size, 'artifacts (without orderBy)');
                        }
                    } catch (retryError) {
                        log('‚ùå Retry also failed:', retryError.message);
                    }
                }
            }
        }
        
        // Create draggable thumbnail for artifact
        function createArtifactThumbnail(fileId, fileData) {
            const div = document.createElement('div');
            div.className = 'artifact-thumbnail';
            div.draggable = true;
            div.dataset.fileId = fileId;
            div.dataset.fileName = fileData.fileName || fileData.name || 'Unnamed';
            div.dataset.fileType = fileData.fileType || 'document';
            div.dataset.downloadUrl = fileData.downloadURL || '';
            div.dataset.fileSize = fileData.fileSize || fileData.size || '0';
            
            // Determine content based on file type
            if (fileData.thumbnailURL) {
                // Use thumbnail if available
                div.innerHTML = `
                    <img src="${fileData.thumbnailURL}" alt="${fileData.fileName}" />
                    <div class="artifact-thumbnail-name">${fileData.fileName || 'Unnamed'}</div>
                `;
            } else if (fileData.fileType && fileData.fileType.startsWith('image/')) {
                // Use download URL for images without thumbnails
                div.innerHTML = `
                    <img src="${fileData.downloadURL}" alt="${fileData.fileName}" />
                    <div class="artifact-thumbnail-name">${fileData.fileName || 'Unnamed'}</div>
                `;
            } else {
                // Use icon for non-image files
                const icon = getFileIcon(fileData.fileType);
                div.innerHTML = `
                    <div class="artifact-thumbnail-icon">${icon}</div>
                    <div class="artifact-thumbnail-name">${fileData.fileName || 'Unnamed'}</div>
                `;
            }
            
            // Add drag event handlers
            div.addEventListener('dragstart', handleArtifactDragStart);
            div.addEventListener('dragend', handleArtifactDragEnd);
            
            return div;
        }
        
        // Handle artifact drag start - following updated FILE_DROP_GUIDE.md
        function handleArtifactDragStart(e) {
            e.target.classList.add('dragging');
            
            // CRITICAL: Set drag data as JSON per FILE_DROP_GUIDE.md
            e.dataTransfer.setData('text/plain', JSON.stringify({
                name: e.target.dataset.fileName,
                type: e.target.dataset.fileType,
                url: e.target.dataset.downloadUrl,
                size: parseInt(e.target.dataset.fileSize) || 0,
                // Add custom metadata
                source: 'artifact-panel',
                fileId: e.target.dataset.fileId,
                timestamp: new Date().toISOString()
            }));
            e.dataTransfer.effectAllowed = 'copy';
            
            log('üöÄ Dragging artifact for attachment:', e.target.dataset.fileName);
        }
        
        // Handle artifact drag end
        function handleArtifactDragEnd(e) {
            e.target.classList.remove('dragging');
        }
        
        // Load user faces from Firebase
        async function loadUserFaces() {
            if (!firebaseInitialized) {
                log('‚è≥ Firebase not initialized yet for faces');
                return;
            }
            
            const user = firebase.auth().currentUser;
            if (!user) {
                log('‚ùå No user logged in for faces');
                const loadingEl = document.getElementById('facesLoading');
                if (loadingEl) {
                    loadingEl.innerHTML = '<div style="color: #666;">Please log in to see faces</div>';
                }
                return;
            }
            
            log('üë§ Loading faces for user:', user.email, 'UID:', user.uid);
            
            const gridEl = document.getElementById('facesGrid');
            const loadingEl = document.getElementById('facesLoading');
            
            if (!gridEl || !loadingEl) {
                log('‚ùå Missing DOM elements for faces');
                return;
            }
            
            try {
                // Get user's files from Firestore
                const db = firebase.firestore();
                const filesRef = db.collection('users').doc(user.uid).collection('files');
                log('üîç Querying for files with faces: users/' + user.uid + '/files');
                
                // Query for files that have extracted faces
                const snapshot = await filesRef.limit(100).get();
                
                log('üìä Files query completed. Size:', snapshot.size);
                
                loadingEl.style.display = 'none';
                gridEl.innerHTML = '';
                
                let totalFaces = 0;
                
                // Iterate through files and extract faces
                snapshot.forEach(doc => {
                    const fileData = doc.data();
                    
                    // Check if file has extracted faces
                    if (fileData.extractedFaces && Array.isArray(fileData.extractedFaces) && fileData.extractedFaces.length > 0) {
                        log('üì∑ Found file with faces:', fileData.fileName, 'Face count:', fileData.extractedFaces.length);
                        
                        // Log first face structure to understand the data
                        if (fileData.extractedFaces[0]) {
                            log('üîç First face structure:', JSON.stringify(fileData.extractedFaces[0]));
                        }
                        
                        // Create face thumbnails for each extracted face
                        fileData.extractedFaces.forEach((face, index) => {
                            const faceThumbnail = createFaceThumbnail(doc.id, fileData, face, index);
                            gridEl.appendChild(faceThumbnail);
                            totalFaces++;
                        });
                    }
                });
                
                log('‚úÖ Loaded', totalFaces, 'faces from', snapshot.size, 'files');
                
                if (totalFaces === 0) {
                    loadingEl.style.display = 'block';
                    loadingEl.innerHTML = '<div style="color: #666;">No faces found. <a href="../pages/my-files.html" style="color: #6B46C1;">Upload and vectorize photos</a></div>';
                }
                
            } catch (error) {
                log('‚ùå Error loading faces:', error.message);
                console.error('Full error:', error);
                loadingEl.innerHTML = '<div style="color: #EF4444;">Error: ' + error.message + '</div>';
            }
        }
        
        // Create draggable face thumbnail
        function createFaceThumbnail(fileId, fileData, face, faceIndex) {
            const div = document.createElement('div');
            div.className = 'face-thumbnail';
            div.draggable = true;
            div.dataset.fileId = fileId;
            div.dataset.fileName = fileData.fileName || 'Unnamed';
            div.dataset.faceId = face.faceId || `face_${faceIndex}`;
            div.dataset.confidence = face.confidence || 0;
            
            // Create loading placeholder
            const loadingDiv = document.createElement('div');
            loadingDiv.style.width = '100%';
            loadingDiv.style.height = '100%';
            loadingDiv.style.background = '#f0f0f0';
            loadingDiv.style.display = 'flex';
            loadingDiv.style.alignItems = 'center';
            loadingDiv.style.justifyContent = 'center';
            loadingDiv.style.fontSize = '24px';
            loadingDiv.textContent = 'üòä';
            div.appendChild(loadingDiv);
            
            // Extract face using bounding box if available
            const boundingBox = face.boundingBox || face.BoundingBox;
            if (fileData.downloadURL && boundingBox) {
                log('üìê Extracting face with bounding box:', JSON.stringify(boundingBox));
                extractFaceFromImage(fileData.downloadURL, boundingBox)
                    .then(faceDataUrl => {
                        // Replace loading placeholder with extracted face
                        div.innerHTML = '';
                        const img = document.createElement('img');
                        img.src = faceDataUrl;
                        img.alt = `Face ${faceIndex + 1}`;
                        div.appendChild(img);
                        
                        // Add confidence badge
                        const confidence = face.confidence || face.Confidence;
                        if (confidence) {
                            const confidenceBadge = document.createElement('div');
                            confidenceBadge.className = 'face-thumbnail-confidence';
                            confidenceBadge.textContent = Math.round(confidence) + '%';
                            div.appendChild(confidenceBadge);
                        }
                        
                        // Add name/label
                        const nameLabel = document.createElement('div');
                        nameLabel.className = 'face-thumbnail-name';
                        nameLabel.textContent = face.name || `Face ${faceIndex + 1}`;
                        div.appendChild(nameLabel);
                    })
                    .catch(error => {
                        log('‚ùå Failed to extract face:', error.message);
                        console.error('Face extraction error:', error);
                        // Show error state instead of placeholder
                        div.innerHTML = '<div style="color: red; font-size: 10px; padding: 5px;">Error</div>';
                    });
            } else {
                log('‚ö†Ô∏è No bounding box for face:', JSON.stringify(face));
                div.innerHTML = '<div style="color: orange; font-size: 10px; padding: 5px;">No box</div>';
            }
            
            // Store face data for drag operation
            div.dataset.faceData = JSON.stringify({
                fileId: fileId,
                fileName: fileData.fileName,
                faceId: face.faceId,
                faceIndex: faceIndex,
                confidence: face.confidence,
                boundingBox: face.boundingBox,
                emotions: face.emotions,
                ageRange: face.ageRange
            });
            
            // Add drag event handlers
            div.addEventListener('dragstart', handleFaceDragStart);
            div.addEventListener('dragend', handleFaceDragEnd);
            
            return div;
        }
        
        // Neo4j Functions for Production Data
        async function initializeNeo4j() {
            try {
                if (typeof neo4j === 'undefined') {
                    throw new Error('Neo4j driver not loaded');
                }
                
                if (!neo4jDriver) {
                    log('üîó Connecting to Neo4j for production data...');
                    neo4jDriver = neo4j.driver(
                        neo4jConfig.uri,
                        neo4j.auth.basic(neo4jConfig.username, neo4jConfig.password)
                    );
                    
                    // Test connection
                    const session = neo4jDriver.session();
                    const result = await session.run('RETURN 1 as test');
                    await session.close();
                    
                    log('‚úÖ Neo4j connection established for production data');
                    return true;
                }
                return true;
            } catch (error) {
                log(`‚ùå Neo4j connection failed: ${error.message}`);
                return false;
            }
        }
        
        async function loadProductionDataFromNeo4j(userId, twinId) {
            try {
                log(`üîç Loading production data for user: ${userId}, twin: ${twinId}`);
                
                // Connect to Neo4j if not already connected
                if (!window.Neo4jConnection.isConnected) {
                    const connected = await window.Neo4jConnection.connect();
                    if (!connected) {
                        throw new Error('Failed to connect to Neo4j');
                    }
                }
                
                // Query nodes for this user/twin
                const nodesResult = await window.Neo4jConnection.run(`
                    MATCH (n {userId: $userId, twinId: $twinId})
                    RETURN n.id as id, labels(n) as labels, properties(n) as props
                    LIMIT 50
                `, { userId, twinId });
                
                // First, let's see what relationships exist in the database
                const allRelsDebug = await window.Neo4jConnection.run(`
                    MATCH (a)-[r]->(b)
                    WHERE a.userId = $userId AND a.twinId = $twinId
                    RETURN a.id as sourceId, b.id as targetId, type(r) as relType, 
                           a.userId as aUserId, a.twinId as aTwinId,
                           b.userId as bUserId, b.twinId as bTwinId
                    LIMIT 10
                `, { userId, twinId });
                
                log(`üîç Debug: Found ${allRelsDebug.records.length} relationships where source node matches user/twin`);
                allRelsDebug.records.forEach((record, i) => {
                    log(`  Rel ${i}: ${record.get('sourceId')} -> ${record.get('targetId')} (${record.get('relType')})`);
                    log(`    Source: userId=${record.get('aUserId')}, twinId=${record.get('aTwinId')}`);
                    log(`    Target: userId=${record.get('bUserId')}, twinId=${record.get('bTwinId')}`);
                });
                
                // Try a more flexible query - just require source node to match
                const relsResult = await window.Neo4jConnection.run(`
                    MATCH (a {userId: $userId, twinId: $twinId})-[r]-(b)
                    RETURN a.id as sourceId, b.id as targetId, type(r) as relType, 
                           properties(r) as relProps, properties(b) as targetProps
                    LIMIT 100
                `, { userId, twinId });
                
                log(`üîç Flexible query found ${relsResult.records.length} relationships`);
                
                // Convert Neo4j results to NexusGraphControl format
                const nodes = nodesResult.records.map((record, index) => {
                    const id = record.get('id');
                    const labels = record.get('labels');
                    const props = record.get('props');
                    const nodeType = labels[0] ? labels[0].toLowerCase() : 'person';
                    
                    return {
                        id: id,
                        position: { 
                            x: 100 + (index % 5) * 150, 
                            y: 100 + Math.floor(index / 5) * 150 
                        },
                        data: {
                            label: props.name || props.firstName ? `${props.firstName || ''} ${props.lastName || ''}`.trim() : id,
                            ...props
                        },
                        type: nodeType,
                        style: {
                            width: 60,
                            height: 60,
                            borderRadius: '50%',
                            backgroundColor: getNodeColor(nodeType),
                            border: '2px solid #333',
                            color: '#fff',
                            fontSize: '12px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center'
                        }
                    };
                });
                
                // Create a set of existing node IDs for validation
                const nodeIds = new Set(nodes.map(n => n.id));
                
                const edges = relsResult.records.map((record, index) => {
                    const sourceId = record.get('sourceId');
                    const targetId = record.get('targetId');
                    const targetProps = record.get('targetProps');
                    const relType = record.get('relType');
                    
                    // If target node isn't in our nodes list, add it
                    if (!nodeIds.has(targetId) && targetProps) {
                        const targetNode = {
                            id: targetId,
                            position: { 
                                x: 300 + (nodes.length % 5) * 150, 
                                y: 300 + Math.floor(nodes.length / 5) * 150 
                            },
                            data: {
                                label: targetProps.name || targetProps.firstName || targetId,
                                ...targetProps
                            },
                            type: 'person', // Default type for connected nodes
                            style: {
                                width: 60,
                                height: 60,
                                borderRadius: '50%',
                                backgroundColor: getNodeColor('person'),
                                border: '2px solid #333',
                                color: '#fff',
                                fontSize: '12px',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center'
                            }
                        };
                        nodes.push(targetNode);
                        nodeIds.add(targetId);
                        log(`‚ûï Added missing target node: ${targetId}`);
                    }
                    
                    // React Flow edge format
                    const edge = {
                        id: `${sourceId}-${targetId}`,
                        source: sourceId,
                        target: targetId,
                        label: relType.toLowerCase(),
                        data: record.get('relProps'),
                        type: 'default'
                    };
                    log(`üîó Edge ${index}: ${edge.source} -> ${edge.target} (${edge.label})`);
                    return edge;
                });
                
                log(`‚úÖ Loaded ${nodes.length} nodes and ${edges.length} relationships from Neo4j`);
                log(`üìä Node IDs: ${nodes.map(n => n.id).join(', ')}`);
                if (edges.length > 0) {
                    log(`üîó First edge example: ${JSON.stringify(edges[0], null, 2)}`);
                } else {
                    log(`‚ö†Ô∏è No relationships found for user ${userId}, twin ${twinId}`);
                }
                
                return { nodes, edges };
                
            } catch (error) {
                log(`‚ùå Failed to load production data: ${error.message}`);
                // Return empty data on error
                return { nodes: [], edges: [] };
            }
        }
        
        // Load actual nodes from Neo4j for the Node List panel
        async function loadNodeList() {
            try {
                log('üîç Loading node list from Neo4j...');
                
                const connected = await initializeNeo4j();
                if (!connected) {
                    showNodeListError('Failed to connect to Neo4j');
                    return;
                }
                
                const user = firebase.auth().currentUser;
                if (!user) {
                    showNodeListError('User not authenticated');
                    return;
                }
                
                const userId = user.uid;
                const twinId = `${userId}-1`;
                
                const session = neo4jDriver.session();
                
                // Query all nodes for this user/twin, grouped by type
                const nodesResult = await session.run(`
                    MATCH (n {userId: $userId, twinId: $twinId})
                    RETURN n.id as id, labels(n) as labels, properties(n) as props
                    ORDER BY labels(n)[0], n.name, n.firstName, n.id
                    LIMIT 100
                `, { userId, twinId });
                
                await session.close();
                
                const container = document.getElementById('nodeListContainer');
                container.innerHTML = '';
                
                if (nodesResult.records.length === 0) {
                    container.innerHTML = `
                        <div style="background: white; padding: 15px; border-radius: 4px; text-align: center; color: #666;">
                            <div style="font-size: 20px; margin-bottom: 5px;">üì≠</div>
                            <div>No nodes found in your graph</div>
                            <small style="color: #999;">Use the Admin page to generate test data</small>
                        </div>
                    `;
                    return;
                }
                
                // Group nodes by type
                const nodesByType = {};
                nodesResult.records.forEach(record => {
                    const props = record.get('props');
                    const labels = record.get('labels');
                    const nodeType = labels[0] ? labels[0].toLowerCase() : 'node';
                    
                    if (!nodesByType[nodeType]) {
                        nodesByType[nodeType] = [];
                    }
                    
                    nodesByType[nodeType].push({
                        id: record.get('id'),
                        label: props.name || props.firstName ? `${props.firstName || ''} ${props.lastName || ''}`.trim() : record.get('id'),
                        type: nodeType,
                        props: props,
                        // Add sorting keys for alphabetical order
                        sortKey: nodeType === 'person' ? 
                            (props.lastName || props.name || record.get('id')).toLowerCase() :
                            (props.name || record.get('id')).toLowerCase()
                    });
                });
                
                // Create filter buttons
                createNodeTypeFilters(nodesByType);
                
                // Store nodes data globally for filtering
                window.nodeListData = nodesByType;
                
                // Render all nodes initially
                renderFilteredNodes(nodesByType);
                
                log(`‚úÖ Loaded ${nodesResult.records.length} nodes for node list`);
                
            } catch (error) {
                log(`‚ùå Error loading node list: ${error.message}`);
                showNodeListError(`Error: ${error.message}`);
            }
        }
        
        function createDraggableNodeElement(node) {
            const div = document.createElement('div');
            div.className = 'node-list-item';
            div.draggable = true;
            div.dataset.nodeId = node.id;
            div.dataset.nodeType = node.type;
            div.dataset.nodeData = JSON.stringify(node);
            
            const color = getNodeColor(node.type);
            
            div.style.cssText = `
                background: white; 
                padding: 10px; 
                border-radius: 4px; 
                border-left: 4px solid ${color}; 
                cursor: grab; 
                transition: all 0.2s;
                margin-bottom: 5px;
            `;
            
            div.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 16px;">${getNodeTypeIcon(node.type)}</span>
                    <div style="flex: 1;">
                        <strong style="color: #333; font-size: 14px;">${node.label}</strong><br>
                        <small style="color: #666;">${node.id}</small>
                    </div>
                </div>
            `;
            
            // Add hover effects
            div.addEventListener('mouseenter', () => {
                div.style.transform = 'translateX(5px)';
                div.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
            });
            
            div.addEventListener('mouseleave', () => {
                div.style.transform = 'translateX(0)';
                div.style.boxShadow = 'none';
            });
            
            // Add drag event handlers
            div.addEventListener('dragstart', (e) => {
                div.style.cursor = 'grabbing';
                
                // Use the drag data format from NODE_DRAG_DROP_GUIDE
                const dragData = {
                    dragType: 'node',           // REQUIRED: Identifies this as a node (not file)
                    sourceControl: 'node-list', // REQUIRED: Must be 'node-list' for the drop to work
                    id: node.id,                // Neo4j node ID
                    name: node.label,           // Display name
                    type: node.type,            // Node type (person, organization, etc.)
                    label: node.label,          // Display label
                    properties: node.props || {}, // All Neo4j properties
                    metadata: {
                        source: 'neo4j',
                        nodeType: node.type,
                        draggedAt: new Date().toISOString(),
                        sourcePanel: 'node-list'
                    },
                    originalData: node          // Complete original node data
                };
                
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
                log(`üèÉ Dragging node: ${node.label} (${node.id}) with type: ${node.type}`);
            });
            
            div.addEventListener('dragend', () => {
                div.style.cursor = 'grab';
            });
            
            return div;
        }
        
        function showNodeListError(message) {
            const container = document.getElementById('nodeListContainer');
            container.innerHTML = `
                <div style="background: white; padding: 15px; border-radius: 4px; text-align: center; color: #dc3545;">
                    <div style="font-size: 20px; margin-bottom: 5px;">‚ùå</div>
                    <div>${message}</div>
                </div>
            `;
        }
        
        function createNodeTypeFilters(nodesByType) {
            const filterContainer = document.getElementById('nodeTypeFilterButtons');
            const filtersDiv = document.getElementById('nodeTypeFilters');
            
            if (!filterContainer || !filtersDiv) return;
            
            filterContainer.innerHTML = '';
            
            // Add "All" button
            const allButton = createFilterButton('all', 'üîÑ', 'All', Object.values(nodesByType).reduce((sum, arr) => sum + arr.length, 0), true);
            filterContainer.appendChild(allButton);
            
            // Add buttons for each node type
            Object.keys(nodesByType).forEach(nodeType => {
                const count = nodesByType[nodeType].length;
                const icon = getNodeTypeIcon(nodeType);
                const label = nodeType.charAt(0).toUpperCase() + nodeType.slice(1) + 's';
                
                const button = createFilterButton(nodeType, icon, label, count, false);
                filterContainer.appendChild(button);
            });
            
            // Show the filters section
            filtersDiv.style.display = 'block';
        }
        
        function createFilterButton(type, icon, label, count, isActive) {
            const button = document.createElement('button');
            button.className = 'node-filter-btn';
            button.dataset.nodeType = type;
            
            const color = type === 'all' ? '#6c757d' : getNodeColor(type);
            const activeClass = isActive ? 'active' : '';
            
            button.style.cssText = `
                padding: 6px 12px;
                border: 1px solid ${color};
                background: ${isActive ? color : 'white'};
                color: ${isActive ? 'white' : color};
                border-radius: 20px;
                cursor: pointer;
                font-size: 12px;
                font-weight: 500;
                display: flex;
                align-items: center;
                gap: 4px;
                transition: all 0.2s;
                user-select: none;
            `;
            
            button.innerHTML = `${icon} ${label} (${count})`;
            
            // Add click handler
            button.addEventListener('click', () => {
                // Remove active state from all buttons
                document.querySelectorAll('.node-filter-btn').forEach(btn => {
                    const btnType = btn.dataset.nodeType;
                    const btnColor = btnType === 'all' ? '#6c757d' : getNodeColor(btnType);
                    btn.style.background = 'white';
                    btn.style.color = btnColor;
                });
                
                // Add active state to clicked button
                button.style.background = color;
                button.style.color = 'white';
                
                // Filter nodes
                filterNodesByType(type);
            });
            
            // Add hover effects
            button.addEventListener('mouseenter', () => {
                if (button.style.background === 'white' || button.style.background === '') {
                    button.style.background = color + '20'; // 20% opacity
                }
            });
            
            button.addEventListener('mouseleave', () => {
                if (button.style.color !== 'white') {
                    button.style.background = 'white';
                }
            });
            
            return button;
        }
        
        function filterNodesByType(selectedType) {
            if (!window.nodeListData) return;
            
            if (selectedType === 'all') {
                renderFilteredNodes(window.nodeListData);
            } else {
                const filteredData = {};
                filteredData[selectedType] = window.nodeListData[selectedType] || [];
                renderFilteredNodes(filteredData);
            }
            
            log(`üîç Filtered node list to show: ${selectedType === 'all' ? 'all types' : selectedType}`);
        }
        
        function renderFilteredNodes(nodesByType) {
            const container = document.getElementById('nodeListContainer');
            container.innerHTML = '';
            
            // Create node elements for each type
            Object.keys(nodesByType).forEach(nodeType => {
                if (nodesByType[nodeType].length === 0) return;
                
                // Add type header
                const typeHeader = document.createElement('div');
                typeHeader.style.cssText = 'font-weight: 600; color: #333; margin: 15px 0 5px 0; font-size: 14px; text-transform: capitalize;';
                typeHeader.innerHTML = `${getNodeTypeIcon(nodeType)} ${nodeType}s (${nodesByType[nodeType].length})`;
                container.appendChild(typeHeader);
                
                // Sort nodes - alphabetically by last name for people, by name for others
                const sortedNodes = [...nodesByType[nodeType]].sort((a, b) => {
                    const aKey = a.sortKey || a.label || a.id;
                    const bKey = b.sortKey || b.label || b.id;
                    return aKey.localeCompare(bKey);
                });
                
                // Add sorted nodes of this type
                sortedNodes.forEach(node => {
                    const nodeElement = createDraggableNodeElement(node);
                    container.appendChild(nodeElement);
                });
            });
        }
        
        // Extract face from image using bounding box
        async function extractFaceFromImage(imageUrl, boundingBox) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous'; // Enable CORS for Firebase Storage URLs
                
                img.onload = function() {
                    // Create canvas for face extraction
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Check if boundingBox exists
                    if (!boundingBox) {
                        reject(new Error('BoundingBox is undefined'));
                        return;
                    }
                    
                    // Convert percentage-based coordinates to pixels
                    // Firebase/AWS uses: Left, Top, Width, Height (all 0-1)
                    const x = (boundingBox.Left || boundingBox.left || boundingBox.x || 0) * img.width;
                    const y = (boundingBox.Top || boundingBox.top || boundingBox.y || 0) * img.height;
                    const width = (boundingBox.Width || boundingBox.width || boundingBox.w || 0) * img.width;
                    const height = (boundingBox.Height || boundingBox.height || boundingBox.h || 0) * img.height;
                    
                    log('üìè Face extraction coords - X:', x, 'Y:', y, 'W:', width, 'H:', height);
                    
                    // Set canvas size to extracted face dimensions (80x80 for thumbnails)
                    const thumbnailSize = 80;
                    canvas.width = thumbnailSize;
                    canvas.height = thumbnailSize;
                    
                    // Draw the face region from the source image, scaled to thumbnail size
                    ctx.drawImage(
                        img,
                        x,                  // Source X (pixels)
                        y,                  // Source Y (pixels)
                        width,              // Source Width (pixels)
                        height,             // Source Height (pixels)
                        0,                  // Destination X
                        0,                  // Destination Y
                        thumbnailSize,      // Destination Width
                        thumbnailSize       // Destination Height
                    );
                    
                    // Convert to data URL
                    const faceDataUrl = canvas.toDataURL('image/jpeg', 0.9);
                    resolve(faceDataUrl);
                };
                
                img.onerror = function() {
                    reject(new Error('Failed to load image for face extraction'));
                };
                
                img.src = imageUrl;
            });
        }
        
        // Handle face drag start
        function handleFaceDragStart(e) {
            e.target.classList.add('dragging');
            
            const faceData = JSON.parse(e.target.dataset.faceData);
            
            // Use node drag format as per NODE_DRAG_DROP_GUIDE.md
            const dragData = {
                dragType: 'node',           // REQUIRED: Identifies this as a node drag
                sourceControl: 'node-list', // REQUIRED: Must be 'node-list' for the drop to work
                id: `face_${faceData.faceId}_${Date.now()}`,
                name: faceData.fileName || `Face ${faceData.faceIndex + 1}`,
                type: 'person',             // Faces represent people
                label: faceData.fileName || `Face ${faceData.faceIndex + 1}`,
                properties: {
                    ...faceData,
                    source: 'faces-panel'
                },
                // Keep original face data for compatibility
                originalData: {
                    type: 'face',
                    ...faceData
                }
            };
            
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('text/plain', JSON.stringify(dragData));
            
            log('üöÄ Dragging face as person node:', dragData.name);
        }
        
        // Handle face drag end
        function handleFaceDragEnd(e) {
            e.target.classList.remove('dragging');
        }
        
        // Create review form content
        function createReviewFormContent() {
            const container = document.createElement('div');
            container.style.cssText = 'padding: 20px;';
            
            // Summary section
            const summary = document.createElement('div');
            summary.style.cssText = 'margin-bottom: 20px;';
            summary.innerHTML = `
                <h3 style="margin-bottom: 10px; color: #374151;">Changes Summary</h3>
                <div style="background: #F3F4F6; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span style="color: #6B7280;">Total Changes:</span>
                        <span style="font-weight: 600; color: #374151;">${changesCount}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span style="color: #6B7280;">Nodes Added:</span>
                        <span style="font-weight: 600; color: #10B981;">${currentSandboxData.nodes.length || 0}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: #6B7280;">Edges Added:</span>
                        <span style="font-weight: 600; color: #3B82F6;">${currentSandboxData.edges.length || 0}</span>
                    </div>
                </div>
            `;
            container.appendChild(summary);
            
            // Review notes section
            const notesSection = document.createElement('div');
            notesSection.style.cssText = 'margin-bottom: 20px;';
            notesSection.innerHTML = `
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: #374151;">
                    Review Notes (Optional)
                </label>
                <textarea 
                    id="reviewNotes" 
                    placeholder="Add any notes about these changes..."
                    style="width: 100%; min-height: 100px; padding: 10px; border: 1px solid #E5E7EB; border-radius: 6px; font-family: inherit; font-size: 14px; resize: vertical;"
                ></textarea>
            `;
            container.appendChild(notesSection);
            
            // Warning section
            const warning = document.createElement('div');
            warning.style.cssText = 'background: #FEF3C7; border: 1px solid #F59E0B; border-radius: 6px; padding: 12px; margin-bottom: 20px;';
            warning.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="color: #F59E0B;">‚ö†Ô∏è</span>
                    <span style="color: #92400E; font-size: 14px;">
                        This action will update the production graph. All changes will be immediately visible to users.
                    </span>
                </div>
            `;
            container.appendChild(warning);
            
            return container;
        }

        // Post to Production function
        async function postToProduction() {
            console.log('üöÄ postToProduction called');
            console.log('üìä Current sandbox data:', currentSandboxData);
            console.log('üî¢ Changes count:', changesCount);
            
            // Double-check we have changes to post
            if (changesCount === 0 || !currentSandboxData.nodes.length) {
                if (window.Modal) {
                    const modal = new window.Modal({
                        title: 'No Changes to Post',
                        content: 'There are no pending changes in the sandbox to post to production.',
                        type: 'info',
                        actions: [
                            {
                                text: 'OK',
                                type: 'primary',
                                action: () => {} // Modal will auto-hide
                            }
                        ]
                    });
                    modal.show();
                } else {
                    alert('No changes to post to production');
                }
                return;
            }
            
            // Close any existing review modal first
            if (activeReviewModal) {
                console.log('üîí Closing existing review modal');
                activeReviewModal.hide();
                activeReviewModal = null;
            }
            
            // Show review form modal
            if (window.Modal) {
                activeReviewModal = new window.Modal({
                    title: 'Review Changes Before Posting',
                    content: createReviewFormContent(),
                    size: 'medium',
                    type: 'default',
                    closable: true,
                    actions: [
                        {
                            text: 'Cancel',
                            type: 'secondary',
                            action: () => {} // Modal will auto-hide
                        },
                        {
                            text: 'Post to Production',
                            type: 'success',
                            icon: 'üì§',
                            action: () => {
                                console.log('üîò Modal Post to Production clicked!');
                                
                                // Get review notes
                                const reviewNotes = document.getElementById('reviewNotes')?.value || '';
                                console.log('üìù Review notes:', reviewNotes);
                                
                                // Hide the review modal immediately
                                console.log('üîí Hiding review modal...');
                                activeReviewModal.hide();
                                activeReviewModal = null;
                                
                                // Proceed with posting after modal is hidden
                                setTimeout(() => {
                                    console.log('üì§ Calling performPostToProduction...');
                                    performPostToProduction(reviewNotes);
                                }, 100);
                            }
                        }
                    ]
                });
                activeReviewModal.show();
            } else {
                // Fallback to simple confirm
                const confirmPost = confirm(`Are you sure you want to post ${changesCount} ${changesCount === 1 ? 'change' : 'changes'} to production?`);
                if (!confirmPost) return;
                await performPostToProduction('');
            }
        }
        
        // Perform the actual post to production
        async function performPostToProduction(reviewNotes) {
            console.log('üöÄ performPostToProduction called');
            console.log('üìù Review notes:', reviewNotes);
            
            try {
                // Disable button during processing
                const button = document.querySelector('#postToProductionButton button');
                if (button && window.Button) {
                    const buttonInstance = button._buttonInstance;
                    if (buttonInstance) {
                        buttonInstance.setLoading(true);
                    }
                }
                
                // Show loading modal
                let loadingModal;
                if (window.Modal) {
                    loadingModal = new window.Modal({
                        title: 'Posting to Production',
                        content: '<div style="text-align: center; padding: 20px;"><div style="font-size: 48px; margin-bottom: 10px;">‚è≥</div><div>Processing changes...</div></div>',
                        size: 'small',
                        closable: false,
                        closeOnBackdrop: false,
                        closeOnEscape: false
                    });
                    loadingModal.show();
                }
                
                // Post to production
                log('üì§ Posting changes to production...');
                log('üìù Review notes:', reviewNotes);
                log('üìä Nodes to save:', currentSandboxData.nodes.length);
                log('üîó Edges to save:', currentSandboxData.edges.length);
                
                // Save to Neo4j
                const success = await saveToNeo4j(currentSandboxData);
                
                if (!success) {
                    throw new Error('Failed to save to Neo4j');
                }
                
                // Reset changes count
                changesCount = 0;
                updateChangesDisplay();
                
                // Hide loading modal
                if (loadingModal) {
                    loadingModal.hide();
                }
                
                // Ensure review modal is closed
                if (activeReviewModal) {
                    console.log('üîí Ensuring review modal is closed after success');
                    activeReviewModal.hide();
                    activeReviewModal = null;
                }
                
                // Show success modal or alert
                if (window.Modal) {
                    const successModal = new window.Modal({
                        title: 'Success!',
                        content: '<div style="text-align: center; padding: 20px;"><div style="font-size: 48px; margin-bottom: 10px; color: #10B981;">‚úÖ</div><div>Changes successfully posted to production!</div></div>',
                        type: 'success',
                        size: 'small',
                        actions: [
                            {
                                text: 'OK',
                                type: 'primary',
                                action: () => {} // Modal will auto-hide
                            }
                        ]
                    });
                    successModal.show();
                } else {
                    alert('‚úÖ Changes successfully posted to production!');
                }
                
                log('‚úÖ Production update complete');
                
                // Re-enable button
                if (button && window.Button) {
                    const buttonInstance = button._buttonInstance;
                    if (buttonInstance) {
                        buttonInstance.setLoading(false);
                    }
                }
                
            } catch (error) {
                log('‚ùå Error posting to production:', error);
                
                // Show error modal or alert
                if (window.Modal) {
                    const errorModal = new window.Modal({
                        title: 'Error',
                        content: 'Failed to post changes to production. Please try again.',
                        type: 'danger',
                        actions: [
                            {
                                text: 'OK',
                                type: 'primary',
                                action: () => {} // Modal will auto-hide
                            }
                        ]
                    });
                    errorModal.show();
                } else {
                    alert('Error posting to production. Please try again.');
                }
                
                // Re-enable button on error
                const button = document.querySelector('#postToProductionButton button');
                if (button && window.Button) {
                    const buttonInstance = button._buttonInstance;
                    if (buttonInstance) {
                        buttonInstance.setLoading(false);
                    }
                }
            }
        }
        
        // Make it globally accessible
        window.postToProduction = postToProduction;

        // Save sandbox data to Neo4j using centralized connection
        async function saveToNeo4j(sandboxData) {
            try {
                // Get user ID and twin ID
                const userId = firebase.auth().currentUser?.uid;
                if (!userId) {
                    throw new Error('User not logged in');
                }
                const twinId = `${userId}-1`;
                
                // Connect to Neo4j if not already connected
                if (!window.Neo4jConnection.isConnected) {
                    const connected = await window.Neo4jConnection.connect();
                    if (!connected) {
                        throw new Error('Failed to connect to Neo4j');
                    }
                }
                
                // Save sandbox data using centralized connection
                const success = await window.Neo4jConnection.saveSandboxToProduction(
                    sandboxData,
                    userId,
                    twinId
                );
                
                if (success) {
                    // Clear sandbox data
                    currentSandboxData = { nodes: [], edges: [] };
                    
                    // Re-render empty sandbox
                    if (sandboxRoot) {
                        const controlElement = React.createElement(window.NexusGraphControl.NexusGraphControl, {
                            data: currentSandboxData,
                            title: "Sandbox",
                            hidePageHeader: true,
                            hideStatusBar: true,
                            useExternalMetadataEditor: false,
                            onDataChange: (newData) => {
                                currentSandboxData = newData;
                                simulateChange();
                            },
                            onNodeDrop: handleSandboxNodeDrop,
                            onFileDrop: handleSandboxFileDrop
                        });
                        
                        sandboxRoot.render(controlElement);
                    }
                    
                    // Refresh production panel if open
                    const productionPanel = document.getElementById('productionPanel');
                    if (productionPanel && productionPanel.classList.contains('open')) {
                        log('üîÑ Refreshing production panel...');
                        await initializeProduction();
                    }
                }
                
                return success;
                
            } catch (error) {
                log('‚ùå Error saving to Neo4j:', error);
                return false;
            }
        }


        // Function to add test data to sandbox (for testing only)
        window.addTestData = function() {
            currentSandboxData = {
                nodes: [
                    { id: 'test_person_1', label: 'Test Person 1', type: 'person', name: 'Test Person 1' },
                    { id: 'test_person_2', label: 'Test Person 2', type: 'person', name: 'Test Person 2' },
                    { id: 'test_event_1', label: 'Test Event', type: 'event', name: 'Test Event' }
                ],
                edges: [
                    { id: 'test_edge_1', source: 'test_person_1', target: 'test_event_1', label: 'ATTENDED' },
                    { id: 'test_edge_2', source: 'test_person_2', target: 'test_event_1', label: 'ORGANIZED' }
                ]
            };
            
            changesCount = 5;
            updateChangesDisplay();
            
            // Re-render sandbox with test data
            if (sandboxRoot) {
                const controlElement = React.createElement(window.NexusGraphControl.NexusGraphControl, {
                    data: currentSandboxData,
                    title: "Sandbox",
                    hidePageHeader: true,
                    hideStatusBar: true,
                    useExternalMetadataEditor: false,
                    onDataChange: (newData) => {
                        currentSandboxData = newData;
                        simulateChange();
                    },
                    onNodeDrop: handleSandboxNodeDrop,
                    onFileDrop: handleSandboxFileDrop
                });
                
                sandboxRoot.render(controlElement);
            }
            
            log('‚úÖ Test data added to sandbox');
        };

        window.addEventListener('load', () => {
            log('üì¶ Page loaded, checking scripts...');
            
            // Initialize Firebase first
            initializeFirebase();
            
            // Initialize Post to Production button
            setTimeout(() => {
                const buttonContainer = document.getElementById('postToProductionButton');
                if (buttonContainer) {
                    if (window.Button) {
                        // Use centralized Button component
                        const button = new window.Button({
                            text: 'Review & Post',
                            type: 'success',
                            icon: 'üìã',
                            disabled: true, // Start disabled since no changes initially
                            onClick: () => {
                                console.log('üîò Review & Post button clicked!');
                                postToProduction();
                            }
                        });
                        buttonContainer.appendChild(button.element);
                        // Store reference for later use
                        button.element._buttonInstance = button;
                        
                        // Also add direct event listener as backup
                        button.element.addEventListener('click', () => {
                            console.log('üîò Direct click event!');
                            postToProduction();
                        });
                        
                        log('‚úÖ Post to Production button initialized with centralized component');
                    } else {
                        // Fallback to simple button
                        const button = document.createElement('button');
                        button.textContent = 'üìã Review & Post';
                        button.onclick = postToProduction;
                        button.disabled = true; // Start disabled
                        button.style.cssText = `
                            background: #10B981;
                            color: white;
                            border: none;
                            padding: 8px 16px;
                            border-radius: 6px;
                            font-size: 14px;
                            font-weight: 500;
                            cursor: not-allowed;
                            opacity: 0.5;
                            display: flex;
                            align-items: center;
                            gap: 6px;
                        `;
                        buttonContainer.appendChild(button);
                        log('‚úÖ Post to Production button initialized with fallback');
                    }
                }
            }, 100);
            
            setTimeout(() => {
                if (checkBundle()) {
                    log('‚úÖ Ready for testing');
                    initializeSandbox();
                    
                    updateToolbarStates();
                } else {
                    log('‚ùå Scripts not loaded properly');
                }
            }, 500);
        });
    </script>
    
    <!-- Centralized Navigation -->
    <script src="../js/navigation.js"></script>
</body>
</html>